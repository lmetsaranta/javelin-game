<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>VKKK Simulator</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { overflow: hidden; background: #000; font-family: 'Courier New', monospace; }
canvas { display: block; }

#ui-overlay {
  position: fixed; top: 0; left: 0; width: 100%; height: 100%;
  pointer-events: none; z-index: 10;
}

/* Title Screen */
#title-screen {
  position: fixed; top: 0; left: 0; width: 100%; height: 100%;
  display: flex; flex-direction: column; align-items: center; justify-content: center;
  background: rgba(0,0,0,0.6); z-index: 20; cursor: pointer;
  pointer-events: all;
}
#title-screen h1 {
  font-size: 4em; color: #d4a043; text-shadow: 3px 3px 8px #000;
  letter-spacing: 4px; margin-bottom: 10px;
}
#title-screen h2 {
  font-size: 1.4em; color: #a0b89c; text-shadow: 2px 2px 4px #000;
  margin-bottom: 40px; font-weight: normal;
}
#title-screen .start-text {
  font-size: 1.2em; color: #ccc; animation: pulse 2s infinite;
}
@keyframes pulse { 0%,100% { opacity: 0.4; } 50% { opacity: 1; } }

/* HUD */
#hud {
  position: fixed; top: 0; left: 0; width: 100%; height: 100%;
  pointer-events: none; z-index: 10; display: none;
}
#crosshair {
  position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%);
  width: 24px; height: 24px;
}
#crosshair::before, #crosshair::after {
  content: ''; position: absolute; background: rgba(255,255,255,0.7);
}
#crosshair::before { width: 2px; height: 24px; left: 11px; top: 0; }
#crosshair::after { width: 24px; height: 2px; top: 11px; left: 0; }

#power-meter {
  position: absolute; right: 40px; top: 50%; transform: translateY(-50%);
  width: 20px; height: 200px; border: 2px solid rgba(255,255,255,0.5);
  background: rgba(0,0,0,0.3); border-radius: 4px; overflow: hidden;
  display: none;
}
#power-fill {
  position: absolute; bottom: 0; width: 100%;
  background: linear-gradient(to top, #4a4, #aa4, #a44);
  transition: height 0.05s;
}

#speed-meter {
  position: absolute; left: 40px; top: 50%; transform: translateY(-50%);
  width: 20px; height: 200px; border: 2px solid rgba(255,255,255,0.5);
  background: rgba(0,0,0,0.3); border-radius: 4px; overflow: hidden;
  display: none;
}
#speed-fill {
  position: absolute; bottom: 0; width: 100%;
  background: linear-gradient(to top, #4a8, #8a4, #a84);
  transition: height 0.05s;
}
#speed-label {
  position: absolute; left: 36px; top: calc(50% + 110px);
  color: rgba(255,255,255,0.6); font-size: 11px; letter-spacing: 1px;
  display: none;
}

#run-instruction {
  position: absolute; bottom: 80px; left: 50%; transform: translateX(-50%);
  color: rgba(255,255,255,0.8); font-size: 16px;
  text-shadow: 1px 1px 3px #000; white-space: nowrap;
  display: none;
}

#touch-run-btn {
  position: absolute; bottom: 130px; left: 50%; transform: translateX(-50%);
  width: 120px; height: 80px; border-radius: 12px;
  background: rgba(255,255,255,0.15); border: 2px solid rgba(255,255,255,0.4);
  color: #fff; font-family: 'Courier New', monospace; font-size: 13px;
  display: none; align-items: center; justify-content: center; text-align: center;
  pointer-events: all; touch-action: none; user-select: none;
  -webkit-user-select: none; line-height: 1.3;
}
#touch-run-btn:active {
  background: rgba(255,255,255,0.35); border-color: #d4a043;
}

#info-panel {
  position: absolute; top: 20px; left: 20px; color: #ddd;
  text-shadow: 1px 1px 3px #000; font-size: 14px; line-height: 1.8;
}

#wind-indicator {
  position: absolute; top: 20px; right: 20px; color: #ddd;
  text-shadow: 1px 1px 3px #000; font-size: 14px; text-align: right;
}

#distance-display {
  position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
  color: #d4a043; font-size: 3em; text-shadow: 2px 2px 6px #000;
  display: none; text-align: center;
}
#distance-display .sub {
  font-size: 0.4em; color: #aaa; display: block; margin-top: 5px;
}

#angle-display {
  position: absolute; bottom: 40px; left: 50%; transform: translateX(-50%);
  color: rgba(255,255,255,0.7); font-size: 14px;
  text-shadow: 1px 1px 3px #000;
}

/* Dialogue */
#dialogue-box {
  position: fixed; bottom: 40px; left: 50%; transform: translateX(-50%);
  width: 700px; max-width: 90vw; background: rgba(10,15,10,0.92);
  border: 2px solid rgba(160,184,156,0.4); border-radius: 8px;
  padding: 20px 24px; z-index: 30; display: none;
  pointer-events: all; cursor: pointer;
}
#dialogue-name {
  color: #d4a043; font-size: 16px; font-weight: bold; margin-bottom: 8px;
}
#dialogue-text {
  color: #ccc; font-size: 15px; line-height: 1.6; min-height: 40px;
}
#dialogue-continue {
  color: rgba(255,255,255,0.4); font-size: 12px; text-align: right;
  margin-top: 8px;
}

/* Result overlay */
#result-overlay {
  position: fixed; top: 0; left: 0; width: 100%; height: 100%;
  display: none; align-items: center; justify-content: center;
  background: rgba(0,0,0,0.5); z-index: 25; pointer-events: all; cursor: pointer;
}
#result-content {
  text-align: center; color: #fff;
}
#result-content h2 { font-size: 3em; margin-bottom: 10px; }
#result-content p { font-size: 1.2em; color: #aaa; }

/* Drinking Minigame UI */
#drink-meter {
  position: absolute; left: 40px; top: 50%; transform: translateY(-50%);
  width: 20px; height: 200px; border: 2px solid rgba(255,255,255,0.5);
  background: rgba(0,0,0,0.3); border-radius: 4px; overflow: hidden;
  display: none;
}
#drink-fill {
  position: absolute; bottom: 0; width: 100%;
  background: linear-gradient(to top, #b8860b, #daa520);
  transition: height 0.05s;
}
#drink-label {
  position: absolute; left: 33px; top: calc(50% + 115px);
  color: rgba(255,255,255,0.6); font-size: 11px; text-align: center;
  text-shadow: 1px 1px 3px #000; display: none;
}

#nausea-meter {
  position: absolute; right: 40px; top: 50%; transform: translateY(-50%);
  width: 20px; height: 200px; border: 2px solid rgba(255,255,255,0.5);
  background: rgba(0,0,0,0.3); border-radius: 4px; overflow: hidden;
  display: none;
}
#nausea-fill {
  position: absolute; bottom: 0; width: 100%;
  background: linear-gradient(to top, #4a4, #aa4, #a44);
  transition: height 0.05s;
}
#nausea-label {
  position: absolute; right: 30px; top: calc(50% + 115px);
  color: rgba(255,255,255,0.6); font-size: 11px; text-align: center;
  text-shadow: 1px 1px 3px #000; display: none;
}

#drink-instruction {
  position: absolute; bottom: 60px; left: 50%; transform: translateX(-50%);
  color: rgba(255,255,255,0.8); font-size: 16px;
  text-shadow: 1px 1px 4px #000; white-space: nowrap; display: none;
}

#nausea-overlay {
  position: fixed; top: 0; left: 0; width: 100%; height: 100%;
  pointer-events: none; z-index: 15; display: none;
  background: radial-gradient(ellipse at center,
    rgba(0,80,0,0) 40%,
    rgba(0,60,0,0.4) 100%);
}

#puke-overlay {
  position: fixed; top: 0; left: 0; width: 100%; height: 100%;
  display: none; align-items: center; justify-content: center;
  flex-direction: column;
  background: rgba(30,60,0,0.85); z-index: 25; pointer-events: all; cursor: pointer;
}
#puke-overlay h2 {
  font-size: 4em; color: #7a3; text-shadow: 3px 3px 8px #000;
  margin-bottom: 20px;
}
#puke-overlay p {
  font-size: 1.2em; color: #aaa;
}
/* Character Select */
#character-select {
  position: fixed; top: 0; left: 0; width: 100%; height: 100%;
  display: none; flex-direction: column; align-items: center; justify-content: center;
  background: rgba(0,0,0,0.75); z-index: 20; pointer-events: all;
}
#character-select h2 {
  font-size: 2em; color: #d4a043; text-shadow: 2px 2px 6px #000;
  margin-bottom: 24px; letter-spacing: 2px;
}
#name-input {
  font-family: 'Courier New', monospace; font-size: 1.2em;
  padding: 10px 16px; width: 260px; text-align: center;
  background: rgba(20,25,20,0.9); color: #ccc; border: 2px solid #4a6a4a;
  border-radius: 6px; outline: none; margin-bottom: 24px;
}
#name-input:focus { border-color: #d4a043; color: #fff; }
.color-grid {
  display: flex; gap: 14px; margin-bottom: 28px; flex-wrap: wrap; justify-content: center;
}
.color-option {
  width: 50px; height: 50px; border-radius: 8px; cursor: pointer;
  border: 3px solid transparent; overflow: hidden; transition: border-color 0.2s;
}
.color-option:hover { border-color: rgba(212,160,67,0.5); }
.color-option.selected { border-color: #d4a043; }
.color-option .jacket-half {
  width: 100%; height: 65%;
}
.color-option .beanie-half {
  width: 100%; height: 35%;
}
#ready-btn {
  font-family: 'Courier New', monospace; font-size: 1.1em;
  padding: 12px 36px; background: #2a4a2a; color: #d4a043;
  border: 2px solid #4a6a4a; border-radius: 6px; cursor: pointer;
  letter-spacing: 2px; transition: background 0.2s;
}
#ready-btn:hover { background: #3a5a3a; }

/* Bottle Toggle */
#bottle-toggle {
  position: absolute; bottom: 20px; right: 20px; width: 80px; height: 90px;
  background: rgba(10,15,10,0.85); border: 2px solid #4a6a4a; border-radius: 8px;
  display: none; flex-direction: column; align-items: center; justify-content: center;
  pointer-events: all; cursor: pointer; transition: opacity 0.3s;
}
#bottle-toggle:hover { border-color: #d4a043; }
#bottle-toggle.completed { border-color: #4a6a4a; opacity: 0.5; pointer-events: none; }
#bottle-toggle-icon { font-size: 36px; }
#bottle-toggle-label { color: #aaa; font-size: 11px; margin-top: 4px; letter-spacing: 1px; }

/* Dice Result Overlay */
#dice-result {
  position: fixed; top: 0; left: 0; width: 100%; height: 100%;
  display: none; flex-direction: column; align-items: center; justify-content: center;
  z-index: 25; pointer-events: none;
  background: rgba(0,0,0,0.3);
  transition: opacity 0.5s;
}
#dice-result.fade-out { opacity: 0; }
.dice-container { display: flex; gap: 20px; }
.die-face {
  width: 120px; height: 120px;
  background: #f5f5f0; border-radius: 12px;
  display: grid;
  grid-template: repeat(3, 1fr) / repeat(3, 1fr);
  padding: 12px;
  box-shadow: 4px 4px 12px rgba(0,0,0,0.5);
}
.die-face .dot {
  width: 20px; height: 20px;
  background: #222; border-radius: 50%;
  align-self: center; justify-self: center;
}
.die-face .dot.hidden { visibility: hidden; }
#mexico-text {
  font-size: 4em; color: #ff4444; font-weight: bold;
  text-shadow: 3px 3px 8px #000, 0 0 30px #ff6600;
  margin-bottom: 20px; letter-spacing: 6px;
  animation: mexicoPulse 0.5s infinite alternate;
  display: none;
}
@keyframes mexicoPulse {
  0% { transform: scale(1); color: #ff4444; }
  100% { transform: scale(1.1); color: #ffaa00; }
}
#dice-throws-remaining {
  color: rgba(255,255,255,0.7); font-size: 14px; margin-top: 15px;
  font-family: 'Courier New', monospace;
}

/* Mobile Controls */
#mobile-controls {
  position: fixed; top: 0; left: 0; width: 100%; height: 100%;
  z-index: 12; pointer-events: none;
}
#touch-aim-zone {
  position: absolute; top: 0; left: 0; width: 100%; height: 60%;
  pointer-events: all; touch-action: none;
}
#touch-drink-btn, #touch-throw-btn {
  position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
  width: 120px; height: 80px; border-radius: 12px;
  background: rgba(255,255,255,0.15); border: 2px solid rgba(255,255,255,0.4);
  color: #fff; font-family: 'Courier New', monospace; font-size: 13px;
  display: flex; align-items: center; justify-content: center; text-align: center;
  pointer-events: all; touch-action: none; user-select: none;
  -webkit-user-select: none; line-height: 1.3;
}
#touch-drink-btn:active, #touch-throw-btn:active {
  background: rgba(255,255,255,0.35); border-color: #d4a043;
}

@media (max-width: 600px) {
  #title-screen h1 { font-size: 2.2em; }
  #title-screen h2 { font-size: 1em; margin-bottom: 20px; }
  #dialogue-box { padding: 14px 16px; }
  #dialogue-text { font-size: 13px; }
  #dialogue-continue { font-size: 11px; }
  #info-panel { font-size: 12px; left: 10px; top: 10px; }
  #wind-indicator { font-size: 12px; right: 10px; top: 10px; }
  #drink-instruction { white-space: normal; text-align: center; max-width: 90vw; font-size: 14px; }
  #angle-display { bottom: 120px; }
  #bottle-toggle { bottom: 120px; right: 10px; width: 65px; height: 75px; }
  #bottle-toggle-label { font-size: 10px; }
  .color-option { width: 40px; height: 40px; }
  #name-input { width: 200px; font-size: 1em; padding: 8px 12px; }
  #drink-meter, #nausea-meter { height: 150px; }
  #power-meter { height: 150px; }
  #speed-meter { height: 150px; }
  #run-instruction { font-size: 13px; bottom: 220px; }
}

</style>
</head>
<body>

<div id="title-screen">
  <h1>VKKK</h1>
  <h2>Simulator</h2>
  <div class="start-text" id="start-text">Click to begin</div>
</div>

<div id="character-select">
  <h2>Choose Your Character</h2>
  <input type="text" id="name-input" placeholder="Enter your name..." maxlength="20">
  <div class="color-grid">
    <div class="color-option selected" data-jacket="0x4a6a4a" data-beanie="0x2a2a2a">
      <div class="jacket-half" style="background:#4a6a4a"></div>
      <div class="beanie-half" style="background:#2a2a2a"></div>
    </div>
    <div class="color-option" data-jacket="0x1a2a4a" data-beanie="0x6a2222">
      <div class="jacket-half" style="background:#1a2a4a"></div>
      <div class="beanie-half" style="background:#6a2222"></div>
    </div>
    <div class="color-option" data-jacket="0x5a2a2a" data-beanie="0x555555">
      <div class="jacket-half" style="background:#5a2a2a"></div>
      <div class="beanie-half" style="background:#555555"></div>
    </div>
    <div class="color-option" data-jacket="0x5a4a2a" data-beanie="0xc8b890">
      <div class="jacket-half" style="background:#5a4a2a"></div>
      <div class="beanie-half" style="background:#c8b890"></div>
    </div>
    <div class="color-option" data-jacket="0x1a1a1a" data-beanie="0x2a3a5a">
      <div class="jacket-half" style="background:#1a1a1a"></div>
      <div class="beanie-half" style="background:#2a3a5a"></div>
    </div>
    <div class="color-option" data-jacket="0x666666" data-beanie="0xdddddd">
      <div class="jacket-half" style="background:#666666"></div>
      <div class="beanie-half" style="background:#dddddd"></div>
    </div>
  </div>
  <button id="ready-btn">READY</button>
</div>

<div id="hud">
  <div id="crosshair"></div>
  <div id="power-meter"><div id="power-fill"></div></div>
  <div id="speed-meter"><div id="speed-fill"></div></div>
  <div id="speed-label">SPEED</div>
  <div id="run-instruction"></div>
  <div id="info-panel"></div>
  <div id="wind-indicator"></div>
  <div id="distance-display"></div>
  <div id="angle-display"></div>
  <div id="drink-meter"><div id="drink-fill"></div></div>
  <div id="drink-label">BOTTLE</div>
  <div id="nausea-meter"><div id="nausea-fill"></div></div>
  <div id="nausea-label">NAUSEA</div>
  <div id="drink-instruction">Hold SPACE to drink ‚Äî but pace yourself!</div>

  <div id="bottle-toggle">
    <div id="bottle-toggle-icon">üç∑</div>
    <div id="bottle-toggle-label">DRINK (D)</div>
  </div>
</div>

<div id="dialogue-box">
  <div id="dialogue-name"></div>
  <div id="dialogue-text"></div>
  <div id="dialogue-continue">Click or Space to continue</div>
</div>

<div id="result-overlay">
  <div id="result-content">
    <h2 id="result-title"></h2>
    <p id="result-sub"></p>
  </div>
</div>

<div id="nausea-overlay"></div>

<div id="puke-overlay">
  <h2>HUUURGH!</h2>
  <p>Click to try again...</p>
</div>

<div id="dice-result">
  <div id="mexico-text">MEXICO!</div>
  <div class="dice-container">
    <div class="die-face" id="die-face-1"></div>
    <div class="die-face" id="die-face-2"></div>
  </div>
  <div id="dice-throws-remaining"></div>
</div>

<div id="mobile-controls" style="display:none">
  <div id="touch-aim-zone"></div>
  <div id="touch-drink-btn">HOLD TO<br>DRINK</div>
  <div id="touch-throw-btn">HOLD TO<br>CHARGE</div>
  <div id="touch-run-btn">HOLD TO<br>RUN</div>
</div>

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.170.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/"
  }
}
</script>

<script type="module">
import * as THREE from 'three';

// ============================================================
// GLOBALS
// ============================================================
let scene, camera, renderer, clock;
let audioCtx;
let pointerLocked = false;
const isMobile = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);

// Game state
const STATES = {
  TITLE: 'TITLE',
  INTRO_DIALOGUE: 'INTRO_DIALOGUE',
  DRINKING_INTRO: 'DRINKING_INTRO',
  DRINKING: 'DRINKING',
  DRINKING_COMPLETE: 'DRINKING_COMPLETE',
  CELEBRATION_CAMERA: 'CELEBRATION_CAMERA',
  PUKE_GAMEOVER: 'PUKE_GAMEOVER',
  AIMING: 'AIMING',
  RUN_UP: 'RUN_UP',
  CHARGING: 'CHARGING',
  THROW_RELEASE: 'THROW_RELEASE',
  FLIGHT: 'FLIGHT',
  LANDED: 'LANDED',
  RESULT: 'RESULT',
  ROUND_DIALOGUE: 'ROUND_DIALOGUE',
  VICTORY: 'VICTORY',
  DEFEAT: 'DEFEAT',
  CHARACTER_SELECT: 'CHARACTER_SELECT',
  BOTTLE2_GAMEOVER: 'BOTTLE2_GAMEOVER'
};

let gameState = STATES.TITLE;
let currentRound = 0; // 0-indexed
let currentThrow = 0;
let bestDistances = [0, 0, 0, 0, 0, 0]; // best per round
let throwDistances = [];
let isNaked = false;

const ROUNDS = [
  { name: "Round 1", target: 30, windBase: 2, desc: "The first throw is usually the best one" },
  { name: "Round 2", target: 38, windBase: 3, desc: "Don't forget to drink..." },
  { name: "Round 3", target: 42, windBase: 5, desc: "Top 8?" },
  { name: "Round 4", target: 48, windBase: 6, desc: "Second bottle starts to have an effect" },
  { name: "Round 5", target: 55, windBase: 8, desc: "It's getting dark in here" },
  { name: "Round 6", target: 60, windBase: 10, desc: "Time to be naked" }
];

// Aim parameters
let aimPitch = 35; // degrees, 5-55
let aimYaw = 0;    // degrees, -20 to 20
let chargePower = 0;
let isCharging = false;
let chargeDirection = 1;

// Wind
let windSpeed = 2;
let windAngle = 0; // radians

// Javelin flight
let javelin = null;
let javelinVel = new THREE.Vector3();
let javelinFlying = false;
let javelinLanded = false;
let javelinHitTree = false;
let landedDistance = 0;
let landedFoul = false;
let landedDrunkFoul = false;

// Arm
let armGroup = null;
let armAnimState = 'idle'; // idle, aiming, windup, release, follow, drinking_idle, drinking_active, drinking_done
let armAnimTime = 0;

// Drinking minigame
let drinkProgress = 0;     // 0‚Üí1: how much of the bottle is drunk
let nauseaLevel = 0;       // 0‚Üí1: puke at 1.0
let isDrinking = false;    // true while Space held during DRINKING state
let wineWobbleIntensity = 0; // persistent camera wobble after drinking
let drinkGulpTimer = 0;    // timer for gulp sound spacing
let lastStomachGurgle = 0; // cooldown for stomach gurgle sound

const DRINK_RATE = 0.12;           // ~8.3s continuous drinking to finish
const NAUSEA_BUILD_RATE = 0.18;    // base nausea gain/sec while drinking
const NAUSEA_DECAY_RATE = 0.08;    // nausea recovery/sec while resting
const DRINK_NAUSEA_ACCEL = 0.12;   // extra nausea scaled by current nausea

// Environment objects
let obstaclePine = null;
let sectorLeftPine = null;
let sectorRightPine = null;
let treesInstanced = null;
let birchInstanced = null;
let forestUsedPositions = [];
let leafParticles = null;
let windParticles = null;
let birdParticles = null;
let celebrationAnimTime = 0;
const CELEBRATION_DURATION = 5.5;
let npcs = [];
let npcMeshes = [];

// Player customization
let playerName = 'Friend';
let playerJacketColor = 0x4a6a4a;
let playerBeanieColor = 0x2a2a2a;

// Second bottle
let bottleNumber = 1;
let bottle2Completed = false;
let bottle2Available = false;
let preBottle2AimPitch = 35;
let preBottle2AimYaw = 0;
let bottle2InProgress = false;

// Beer can
let beerAvailable = false;
let beerFinished = false;
let beerDrinkProgress = 0;
let beerBoostActive = false;
let isDrinkingBeer = false;
const BEER_DRINK_RATE = 0.25;
const BEER_NAUSEA_BUILD = 0.10;
const BEER_NAUSEA_DECAY = 0.08;
const BEER_NAUSEA_ACCEL = 0.06;

// Dice
let diceAvailable = false;
let diceThrowsRemaining = 3;
let diceFlying = false;
let diceLanded = false;
let diceResultTimer = 0;
let diceValues = [1, 1];
let diceMeshes = [];
let diceVelocities = [];
let diceAngularVels = [];
let mexicoActive = false;
let fireworkParticles = null;
let fireworkTimer = 0;

// Item cycling
let currentItemIndex = 0;

const BOTTLE2_DRINK_RATE = 0.08;
const BOTTLE2_NAUSEA_BUILD_RATE = 0.40;
const BOTTLE2_NAUSEA_DECAY_RATE = 0.04;
const BOTTLE2_NAUSEA_ACCEL = 0.30;

// NPC walk animation
let npcIsWalking = false;
let npcWalkProgress = 0;
const NPC_WALK_DURATION = 4.0;

// Camera
let PLAYER_POS = new THREE.Vector3(0, 1.7, 0);
const THROW_DIR = new THREE.Vector3(0, 0, -1); // forward is -Z

// Run-up
let runUpSpeed = 0;          // 0‚Äì1 normalized
let playerRunZ = 0;          // current Z during run
let isRunning = false;        // W held?
let playerBodyModel = null;   // 3rd person mesh
let throwReleaseTimer = 0;    // timer for throw animation
const RUN_START_Z = 8;       // start 8m behind origin
const FOUL_LINE_Z = 1.0;     // existing pine root location

// Dialogue system
let dialogueQueue = [];
let dialogueActive = false;
let dialogueCharIndex = 0;
let dialogueFullText = '';
let dialogueTimer = 0;
let dialogueCallback = null;

// ============================================================
// TERRAIN HEIGHT
// ============================================================
function getTerrainHeight(x, z) {
  const hillCenterX = 0;
  const hillCenterZ = 2;
  const hillPeak = 7;
  const hillRadiusX = 35;
  const hillRadiusZ = 45;

  const dx = (x - hillCenterX) / hillRadiusX;
  const dz = (z - hillCenterZ) / hillRadiusZ;
  let h = hillPeak * Math.exp(-(dx * dx + dz * dz));

  // Extra side dropoff for steep left/right slopes
  const absX = Math.abs(x);
  if (absX > 5) {
    const sideFactor = (absX - 5) / 30;
    h -= sideFactor * sideFactor * 2.5;
  }

  // Subtle sinusoidal noise for natural feel
  h += Math.sin(x * 0.3 + z * 0.2) * 0.15;
  h += Math.cos(x * 0.15 + z * 0.35) * 0.1;
  h += Math.sin(x * 0.5) * 0.08;

  return h;
}

function easeInOutCubic(t) {
  return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
}

// Set player height on terrain
PLAYER_POS.y = getTerrainHeight(0, 0) + 1.7;

// Custom shader chunks
const treeSway = `
  float sway = sin(time * 1.5 + position.x * 0.5 + position.z * 0.3) * 0.02;
  sway += sin(time * 2.3 + position.x * 0.8) * 0.01;
  float swayAmount = max(0.0, (position.y - 2.0) / 8.0);
  transformed.x += sway * swayAmount * windStr;
  transformed.z += sway * 0.5 * swayAmount * windStr;
`;

// ============================================================
// AUDIO
// ============================================================
function initAudio() {
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
}

function playSound(type, params = {}) {
  if (!audioCtx) return;
  if (audioCtx.state === 'suspended') audioCtx.resume();
  const now = audioCtx.currentTime;

  switch(type) {
    case 'throw': {
      // Grunt
      const gruntOsc = audioCtx.createOscillator();
      const gruntGain = audioCtx.createGain();
      gruntOsc.type = 'sawtooth';
      gruntOsc.frequency.setValueAtTime(120, now);
      gruntOsc.frequency.exponentialRampToValueAtTime(80, now + 0.2);
      gruntGain.gain.setValueAtTime(0.15, now);
      gruntGain.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
      gruntOsc.connect(gruntGain).connect(audioCtx.destination);
      gruntOsc.start(now); gruntOsc.stop(now + 0.3);

      // Whoosh
      const bufferSize = audioCtx.sampleRate * 0.4;
      const noiseBuffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
      const data = noiseBuffer.getChannelData(0);
      for (let i = 0; i < bufferSize; i++) data[i] = (Math.random() * 2 - 1);
      const noise = audioCtx.createBufferSource();
      noise.buffer = noiseBuffer;
      const bandpass = audioCtx.createBiquadFilter();
      bandpass.type = 'bandpass';
      bandpass.frequency.setValueAtTime(800, now);
      bandpass.frequency.exponentialRampToValueAtTime(2000, now + 0.2);
      bandpass.Q.value = 2;
      const whooshGain = audioCtx.createGain();
      whooshGain.gain.setValueAtTime(0.001, now);
      whooshGain.gain.linearRampToValueAtTime(0.2, now + 0.1);
      whooshGain.gain.exponentialRampToValueAtTime(0.001, now + 0.4);
      noise.connect(bandpass).connect(whooshGain).connect(audioCtx.destination);
      noise.start(now); noise.stop(now + 0.4);
      break;
    }
    case 'flight': {
      const bufferSize = audioCtx.sampleRate * 2;
      const noiseBuffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
      const data = noiseBuffer.getChannelData(0);
      for (let i = 0; i < bufferSize; i++) data[i] = (Math.random() * 2 - 1);
      const noise = audioCtx.createBufferSource();
      noise.buffer = noiseBuffer;
      noise.loop = true;
      const bp = audioCtx.createBiquadFilter();
      bp.type = 'bandpass'; bp.frequency.value = 600; bp.Q.value = 3;
      const g = audioCtx.createGain();
      g.gain.setValueAtTime(0.08, now);
      g.gain.linearRampToValueAtTime(0.001, now + 2.5);
      noise.connect(bp).connect(g).connect(audioCtx.destination);
      noise.start(now); noise.stop(now + 2.5);
      break;
    }
    case 'impact': {
      const osc = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      osc.type = 'sine';
      osc.frequency.setValueAtTime(150, now);
      osc.frequency.exponentialRampToValueAtTime(40, now + 0.2);
      g.gain.setValueAtTime(0.3, now);
      g.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
      osc.connect(g).connect(audioCtx.destination);
      osc.start(now); osc.stop(now + 0.3);

      // Leaf rustle
      const bs = audioCtx.sampleRate * 0.3;
      const nb = audioCtx.createBuffer(1, bs, audioCtx.sampleRate);
      const d = nb.getChannelData(0);
      for (let i = 0; i < bs; i++) d[i] = (Math.random() * 2 - 1);
      const n = audioCtx.createBufferSource(); n.buffer = nb;
      const hp = audioCtx.createBiquadFilter();
      hp.type = 'highpass'; hp.frequency.value = 3000;
      const ng = audioCtx.createGain();
      ng.gain.setValueAtTime(0.15, now);
      ng.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
      n.connect(hp).connect(ng).connect(audioCtx.destination);
      n.start(now); n.stop(now + 0.3);
      break;
    }
    case 'tree_hit': {
      // Loud crack
      const osc = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      osc.type = 'square';
      osc.frequency.setValueAtTime(400, now);
      osc.frequency.exponentialRampToValueAtTime(60, now + 0.15);
      g.gain.setValueAtTime(0.4, now);
      g.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
      osc.connect(g).connect(audioCtx.destination);
      osc.start(now); osc.stop(now + 0.2);

      // Wood crack noise
      const bs = audioCtx.sampleRate * 0.15;
      const nb = audioCtx.createBuffer(1, bs, audioCtx.sampleRate);
      const d = nb.getChannelData(0);
      for (let i = 0; i < bs; i++) d[i] = (Math.random() * 2 - 1) * (1 - i/bs);
      const n = audioCtx.createBufferSource(); n.buffer = nb;
      const ng = audioCtx.createGain();
      ng.gain.setValueAtTime(0.35, now);
      ng.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
      n.connect(ng).connect(audioCtx.destination);
      n.start(now); n.stop(now + 0.15);
      break;
    }
    case 'charge': {
      const osc = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      osc.type = 'sine';
      osc.frequency.setValueAtTime(200 + (params.power || 0) * 400, now);
      g.gain.setValueAtTime(0.06, now);
      g.gain.exponentialRampToValueAtTime(0.001, now + 0.08);
      osc.connect(g).connect(audioCtx.destination);
      osc.start(now); osc.stop(now + 0.08);
      break;
    }
    case 'cheer': {
      for (let i = 0; i < 4; i++) {
        const delay = i * 0.1 + Math.random() * 0.05;
        const osc = audioCtx.createOscillator();
        const g = audioCtx.createGain();
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(200 + Math.random() * 300, now + delay);
        g.gain.setValueAtTime(0.05, now + delay);
        g.gain.exponentialRampToValueAtTime(0.001, now + delay + 0.5);
        osc.connect(g).connect(audioCtx.destination);
        osc.start(now + delay); osc.stop(now + delay + 0.5);
      }
      break;
    }
    case 'laugh': {
      for (let i = 0; i < 6; i++) {
        const t = now + i * 0.12;
        const osc = audioCtx.createOscillator();
        const g = audioCtx.createGain();
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(i % 2 === 0 ? 180 : 140, t);
        g.gain.setValueAtTime(0.06, t);
        g.gain.exponentialRampToValueAtTime(0.001, t + 0.1);
        osc.connect(g).connect(audioCtx.destination);
        osc.start(t); osc.stop(t + 0.1);
      }
      break;
    }
    case 'gulp': {
      // Sine chirp + bubble oscillator
      const osc = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      osc.type = 'sine';
      osc.frequency.setValueAtTime(300, now);
      osc.frequency.exponentialRampToValueAtTime(150, now + 0.08);
      g.gain.setValueAtTime(0.12, now);
      g.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
      osc.connect(g).connect(audioCtx.destination);
      osc.start(now); osc.stop(now + 0.1);

      // Bubble
      const bub = audioCtx.createOscillator();
      const bg = audioCtx.createGain();
      bub.type = 'sine';
      bub.frequency.setValueAtTime(600 + Math.random() * 200, now);
      bub.frequency.exponentialRampToValueAtTime(200, now + 0.06);
      bg.gain.setValueAtTime(0.06, now + 0.02);
      bg.gain.exponentialRampToValueAtTime(0.001, now + 0.08);
      bub.connect(bg).connect(audioCtx.destination);
      bub.start(now + 0.02); bub.stop(now + 0.08);
      break;
    }
    case 'stomach_gurgle': {
      const osc = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      const lp = audioCtx.createBiquadFilter();
      osc.type = 'sawtooth';
      osc.frequency.setValueAtTime(60 + Math.random() * 30, now);
      osc.frequency.linearRampToValueAtTime(40 + Math.random() * 20, now + 0.4);
      lp.type = 'lowpass'; lp.frequency.value = 200; lp.Q.value = 5;
      g.gain.setValueAtTime(0.1, now);
      g.gain.linearRampToValueAtTime(0.15, now + 0.15);
      g.gain.exponentialRampToValueAtTime(0.001, now + 0.5);
      osc.connect(lp).connect(g).connect(audioCtx.destination);
      osc.start(now); osc.stop(now + 0.5);
      break;
    }
    case 'puke': {
      // Sawtooth retch
      const osc = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      osc.type = 'sawtooth';
      osc.frequency.setValueAtTime(100, now);
      osc.frequency.linearRampToValueAtTime(180, now + 0.15);
      osc.frequency.linearRampToValueAtTime(60, now + 0.5);
      g.gain.setValueAtTime(0.25, now);
      g.gain.linearRampToValueAtTime(0.3, now + 0.15);
      g.gain.exponentialRampToValueAtTime(0.001, now + 0.6);
      osc.connect(g).connect(audioCtx.destination);
      osc.start(now); osc.stop(now + 0.6);

      // Noise splatter
      const bs = audioCtx.sampleRate * 0.4;
      const nb = audioCtx.createBuffer(1, bs, audioCtx.sampleRate);
      const d = nb.getChannelData(0);
      for (let i = 0; i < bs; i++) d[i] = (Math.random() * 2 - 1) * (1 - i / bs);
      const n = audioCtx.createBufferSource(); n.buffer = nb;
      const lp = audioCtx.createBiquadFilter();
      lp.type = 'lowpass'; lp.frequency.value = 800;
      const ng = audioCtx.createGain();
      ng.gain.setValueAtTime(0.2, now + 0.1);
      ng.gain.exponentialRampToValueAtTime(0.001, now + 0.5);
      n.connect(lp).connect(ng).connect(audioCtx.destination);
      n.start(now + 0.1); n.stop(now + 0.5);
      break;
    }
    case 'burp': {
      const osc = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      const lp = audioCtx.createBiquadFilter();
      osc.type = 'sawtooth';
      osc.frequency.setValueAtTime(90, now);
      osc.frequency.exponentialRampToValueAtTime(50, now + 0.3);
      lp.type = 'lowpass'; lp.frequency.value = 250; lp.Q.value = 3;
      g.gain.setValueAtTime(0.15, now);
      g.gain.linearRampToValueAtTime(0.2, now + 0.1);
      g.gain.exponentialRampToValueAtTime(0.001, now + 0.4);
      osc.connect(lp).connect(g).connect(audioCtx.destination);
      osc.start(now); osc.stop(now + 0.4);
      break;
    }
    case 'ambient': {
      // Forest wind loop
      const bs = audioCtx.sampleRate * 4;
      const nb = audioCtx.createBuffer(1, bs, audioCtx.sampleRate);
      const d = nb.getChannelData(0);
      for (let i = 0; i < bs; i++) {
        d[i] = (Math.random() * 2 - 1) * 0.5;
        if (i > 0) d[i] = d[i] * 0.3 + d[i-1] * 0.7; // smooth
      }
      const n = audioCtx.createBufferSource(); n.buffer = nb; n.loop = true;
      const lp = audioCtx.createBiquadFilter();
      lp.type = 'lowpass'; lp.frequency.value = 400;
      const ng = audioCtx.createGain(); ng.gain.value = 0.04;
      n.connect(lp).connect(ng).connect(audioCtx.destination);
      n.start(now);
      break;
    }
  }
}

// ============================================================
// PROCEDURAL TEXTURES
// ============================================================
function createLeafTexture() {
  const c = document.createElement('canvas');
  c.width = 256; c.height = 256;
  const ctx = c.getContext('2d');
  // Base brown/orange
  ctx.fillStyle = '#6b4226';
  ctx.fillRect(0, 0, 256, 256);
  // Random leaves
  for (let i = 0; i < 800; i++) {
    const x = Math.random() * 256;
    const y = Math.random() * 256;
    const size = 3 + Math.random() * 8;
    const colors = ['#8B4513', '#A0522D', '#CD853F', '#D2691E', '#B8860B', '#DAA520', '#CC7722', '#6B3A2A'];
    ctx.fillStyle = colors[Math.floor(Math.random() * colors.length)];
    ctx.beginPath();
    ctx.ellipse(x, y, size, size * 0.6, Math.random() * Math.PI, 0, Math.PI * 2);
    ctx.fill();
  }
  // Noise
  for (let i = 0; i < 2000; i++) {
    const x = Math.random() * 256;
    const y = Math.random() * 256;
    ctx.fillStyle = `rgba(${Math.random()*40},${Math.random()*20},0,0.15)`;
    ctx.fillRect(x, y, 2, 2);
  }
  const tex = new THREE.CanvasTexture(c);
  tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
  tex.repeat.set(40, 40);
  return tex;
}

function createBarkTexture() {
  const c = document.createElement('canvas');
  c.width = 64; c.height = 128;
  const ctx = c.getContext('2d');
  // Reddish-brown scots pine bark
  ctx.fillStyle = '#7a4a2a';
  ctx.fillRect(0, 0, 64, 128);
  for (let y = 0; y < 128; y += 3) {
    ctx.fillStyle = `rgba(${80 + Math.random()*40},${40 + Math.random()*20},${20 + Math.random()*15},0.5)`;
    ctx.fillRect(0, y, 64, 2 + Math.random() * 3);
  }
  for (let i = 0; i < 100; i++) {
    ctx.fillStyle = `rgba(${60+Math.random()*60},${30+Math.random()*30},${15+Math.random()*20},0.3)`;
    ctx.fillRect(Math.random()*64, Math.random()*128, 3+Math.random()*8, 1+Math.random()*4);
  }
  const tex = new THREE.CanvasTexture(c);
  tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
  return tex;
}

function createSkyTexture() {
  const c = document.createElement('canvas');
  c.width = 512; c.height = 512;
  const ctx = c.getContext('2d');
  const grad = ctx.createLinearGradient(0, 0, 0, 512);
  // Clear autumn sky ‚Äî blue at top, warm haze at horizon
  grad.addColorStop(0, '#4a6a8a');
  grad.addColorStop(0.25, '#6a8aaa');
  grad.addColorStop(0.5, '#8aaabb');
  grad.addColorStop(0.75, '#b0c0c8');
  grad.addColorStop(1, '#c8c0a8');
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, 512, 512);
  // Light wispy clouds
  for (let i = 0; i < 1500; i++) {
    const x = Math.random() * 512;
    const y = Math.random() * 200;
    const a = Math.random() * 0.06;
    ctx.fillStyle = `rgba(220,225,230,${a})`;
    ctx.beginPath();
    ctx.arc(x, y, 5 + Math.random() * 15, 0, Math.PI * 2);
    ctx.fill();
  }
  return new THREE.CanvasTexture(c);
}

// ============================================================
// KUPLAHALLI (Inflatable Dome)
// ============================================================
function createKuplahalliTexture() {
  const c = document.createElement('canvas');
  c.width = 512; c.height = 512;
  const ctx = c.getContext('2d');
  // White/light-gray base
  ctx.fillStyle = '#e8e4e0';
  ctx.fillRect(0, 0, 512, 512);
  // Diagonal crosshatch creating diamond/quilted pattern
  ctx.strokeStyle = 'rgba(180,175,170,0.4)';
  ctx.lineWidth = 1.5;
  const spacing = 24;
  for (let i = -512; i < 1024; i += spacing) {
    ctx.beginPath();
    ctx.moveTo(i, 0);
    ctx.lineTo(i + 512, 512);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(i + 512, 0);
    ctx.lineTo(i, 512);
    ctx.stroke();
  }
  // Subtle seam lines (horizontal)
  ctx.strokeStyle = 'rgba(160,155,150,0.3)';
  ctx.lineWidth = 2;
  for (let y = 0; y < 512; y += 64) {
    ctx.beginPath();
    ctx.moveTo(0, y);
    ctx.lineTo(512, y);
    ctx.stroke();
  }
  const tex = new THREE.CanvasTexture(c);
  tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
  tex.repeat.set(4, 4);
  return tex;
}

function createKuplahalli() {
  const kuplaGroup = new THREE.Group();
  const kx = 50, kz = -60;
  const baseY = getTerrainHeight(kx, kz);

  // Main dome: elongated half-sphere (ellipsoid)
  const domeGeo = new THREE.SphereGeometry(1, 32, 16, 0, Math.PI * 2, 0, Math.PI / 2);
  const domeMat = new THREE.MeshStandardMaterial({
    map: createKuplahalliTexture(),
    roughness: 0.6,
    metalness: 0.05,
    color: 0xf0ece8
  });
  const dome = new THREE.Mesh(domeGeo, domeMat);
  dome.scale.set(17.5, 14, 30); // ~35 wide, ~14 tall, ~60 long
  dome.position.set(kx, baseY, kz);
  dome.castShadow = true;
  dome.receiveShadow = true;
  kuplaGroup.add(dome);

  // Dark rectangular entrance at one end
  const entranceGeo = new THREE.BoxGeometry(6, 5, 3);
  const entranceMat = new THREE.MeshStandardMaterial({
    color: 0x2a2a2a,
    roughness: 0.9
  });
  const entrance = new THREE.Mesh(entranceGeo, entranceMat);
  entrance.position.set(kx, baseY + 2.5, kz + 31);
  kuplaGroup.add(entrance);

  // Entrance opening (dark inset)
  const doorGeo = new THREE.BoxGeometry(3.5, 3.8, 0.5);
  const doorMat = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 1 });
  const door = new THREE.Mesh(doorGeo, doorMat);
  door.position.set(kx, baseY + 2, kz + 32.6);
  kuplaGroup.add(door);

  // Metal fence posts around perimeter (dark green)
  const fencePostGeo = new THREE.CylinderGeometry(0.08, 0.08, 1.5, 6);
  const fencePostMat = new THREE.MeshStandardMaterial({
    color: 0x2a5a2a,
    roughness: 0.4,
    metalness: 0.7
  });
  const fenceRailMat = new THREE.MeshStandardMaterial({
    color: 0x2a5a2a,
    roughness: 0.4,
    metalness: 0.7
  });
  const fenceSpacing = 4;

  // Helper: add post and rails between posts
  function addFenceSection(x1, z1, x2, z2) {
    const fy1 = getTerrainHeight(x1, z1);
    const post = new THREE.Mesh(fencePostGeo, fencePostMat);
    post.position.set(x1, fy1 + 0.75, z1);
    kuplaGroup.add(post);

    // Horizontal rails to next post
    if (x2 !== undefined) {
      const fy2 = getTerrainHeight(x2, z2);
      const dx = x2 - x1, dz = z2 - z1;
      const dist = Math.sqrt(dx * dx + dz * dz);
      const midX = (x1 + x2) / 2, midZ = (z1 + z2) / 2;
      const midY = (fy1 + fy2) / 2;
      const angle = Math.atan2(dx, dz);
      for (const rh of [0.3, 0.7]) {
        const railGeo = new THREE.BoxGeometry(0.04, 0.06, dist);
        const rail = new THREE.Mesh(railGeo, fenceRailMat);
        rail.position.set(midX, midY + rh, midZ);
        rail.rotation.y = angle;
        kuplaGroup.add(rail);
      }
    }
  }

  // Posts along both long sides with rails
  for (const side of [-1, 1]) {
    const prevPosts = [];
    for (let fz = -28; fz <= 28; fz += fenceSpacing) {
      const fx = kx + side * 19;
      prevPosts.push({ x: fx, z: kz + fz });
    }
    for (let i = 0; i < prevPosts.length; i++) {
      const p = prevPosts[i];
      const next = i < prevPosts.length - 1 ? prevPosts[i + 1] : undefined;
      addFenceSection(p.x, p.z, next ? next.x : undefined, next ? next.z : undefined);
    }
  }
  // Posts along back end with rails
  const backPosts = [];
  for (let fx = kx - 18; fx <= kx + 18; fx += fenceSpacing) {
    backPosts.push({ x: fx, z: kz - 30 });
  }
  for (let i = 0; i < backPosts.length; i++) {
    const p = backPosts[i];
    const next = i < backPosts.length - 1 ? backPosts[i + 1] : undefined;
    addFenceSection(p.x, p.z, next ? next.x : undefined, next ? next.z : undefined);
  }

  // Light poles (2, at x ¬± 22 from dome center)
  const poleMat = new THREE.MeshStandardMaterial({ color: 0x555555, roughness: 0.5, metalness: 0.6 });
  const fixtureMat = new THREE.MeshStandardMaterial({ color: 0x666655, roughness: 0.6, emissive: 0x444430, emissiveIntensity: 0.5 });
  for (const side of [-1, 1]) {
    const px = kx + side * 22;
    const pz = kz;
    const py = getTerrainHeight(px, pz);
    const shaft = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.1, 8, 6), poleMat);
    shaft.position.set(px, py + 4, pz);
    shaft.castShadow = true;
    kuplaGroup.add(shaft);

    const fixture = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.15, 0.3), fixtureMat);
    fixture.position.set(px, py + 8.1, pz);
    kuplaGroup.add(fixture);
  }

  scene.add(kuplaGroup);
}

// ============================================================
// SCENE SETUP
// ============================================================
function initScene() {
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x7a9ab8);

  camera = new THREE.PerspectiveCamera(118, window.innerWidth / window.innerHeight, 0.1, 500);
  camera.position.copy(PLAYER_POS);

  renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;
  renderer.toneMapping = THREE.ACESFilmicToneMapping;
  renderer.toneMappingExposure = 0.9;
  document.body.appendChild(renderer.domElement);

  clock = new THREE.Clock();

  // Lighting
  const hemiLight = new THREE.HemisphereLight(0xb0bfc5, 0x6a5a3a, 0.8);
  scene.add(hemiLight);

  const dirLight = new THREE.DirectionalLight(0xd4b888, 0.7);
  dirLight.position.set(-20, 30, -10);
  dirLight.castShadow = true;
  dirLight.shadow.mapSize.set(1024, 1024);
  dirLight.shadow.camera.near = 0.5;
  dirLight.shadow.camera.far = 120;
  dirLight.shadow.camera.left = -60;
  dirLight.shadow.camera.right = 60;
  dirLight.shadow.camera.top = 60;
  dirLight.shadow.camera.bottom = -60;
  scene.add(dirLight);

  const ambLight = new THREE.AmbientLight(0x404850, 0.3);
  scene.add(ambLight);

  // Low-angle golden fill light (warm autumn atmosphere)
  const warmFill = new THREE.DirectionalLight(0xdda040, 0.25);
  warmFill.position.set(30, 8, -5);
  scene.add(warmFill);

  // Sky dome
  const skyGeo = new THREE.SphereGeometry(400, 16, 16);
  const skyMat = new THREE.MeshBasicMaterial({
    map: createSkyTexture(),
    side: THREE.BackSide,
    fog: false
  });
  scene.add(new THREE.Mesh(skyGeo, skyMat));

  // Ground
  createGround();

  // Football field behind sector
  createFootballField();

  // Parking lot near kuplahalli
  createParkingLot();

  // Ground scatter rocks
  createGroundRocks();

  // Trees
  createForest();

  // Birch trees (golden autumn mix)
  createBirchTrees();

  // Sector pines and obstacle
  createSectorTrees();

  // Pine root foul line
  createFoulLine();

  // Chalk foul line marker
  createFoulLineMarker();

  // Throwing boulder
  createThrowingBoulder();

  // NPCs
  createNPCs();

  // Falling leaves
  createLeafParticles();

  // Wind particles
  createWindParticles();

  // Bird particles
  createBirdParticles();

  // Kuplahalli
  createKuplahalli();

  // Player arm
  createPlayerArm();

  // Create javelin template
  createJavelinTemplate();
}

// ============================================================
// GROUND
// ============================================================
function createGround() {
  const geo = new THREE.PlaneGeometry(300, 300, 180, 180);
  const pos = geo.attributes.position;
  for (let i = 0; i < pos.count; i++) {
    const x = pos.getX(i);
    const z = pos.getY(i); // before rotation
    pos.setZ(i, getTerrainHeight(x, z));
  }
  geo.computeVertexNormals();
  geo.rotateX(-Math.PI / 2);

  const mat = new THREE.MeshStandardMaterial({
    map: createLeafTexture(),
    roughness: 0.95,
    metalness: 0.0,
    color: 0x8a6a4a
  });

  const ground = new THREE.Mesh(geo, mat);
  ground.receiveShadow = true;
  scene.add(ground);
}

// ============================================================
// FOOTBALL FIELD & PARKING LOT
// ============================================================
function createFootballField() {
  // Green football field CROSSWISE (long axis = X), visible through trees
  // 105m long (X) x 68m wide (Z), centered behind the forest
  const fieldGeo = new THREE.PlaneGeometry(105, 68);
  fieldGeo.rotateX(-Math.PI / 2);
  const fieldMat = new THREE.MeshStandardMaterial({
    color: 0x3a7a2a,
    roughness: 0.9,
    metalness: 0.0
  });
  const field = new THREE.Mesh(fieldGeo, fieldMat);
  const fieldZ = -118; // near edge at z=-84, far edge at z=-152
  const fieldY = getTerrainHeight(0, fieldZ) + 0.1;
  field.position.set(0, fieldY, fieldZ);
  field.receiveShadow = true;
  scene.add(field);

  // White line markings (long sides along X, short sides along Z)
  const lineMat = new THREE.MeshStandardMaterial({ color: 0xeeeeee, roughness: 0.8 });
  const lineW = 0.15;

  const lines = [
    // Long sides (along X axis)
    { w: 105, d: lineW, x: 0, z: -34 },
    { w: 105, d: lineW, x: 0, z: 34 },
    // Short sides (along Z axis)
    { w: lineW, d: 68, x: -52.5, z: 0 },
    { w: lineW, d: 68, x: 52.5, z: 0 },
    // Center line
    { w: lineW, d: 68, x: 0, z: 0 },
  ];
  lines.forEach(l => {
    const geo = new THREE.PlaneGeometry(l.w, l.d);
    geo.rotateX(-Math.PI / 2);
    const line = new THREE.Mesh(geo, lineMat);
    line.position.set(l.x, 0.02, l.z);
    field.add(line);
  });

  // Center circle
  const circleGeo = new THREE.RingGeometry(9, 9.15, 32);
  circleGeo.rotateX(-Math.PI / 2);
  const circle = new THREE.Mesh(circleGeo, lineMat);
  circle.position.y = 0.02;
  field.add(circle);

  // Goal areas at each SHORT end (left/right in X)
  for (const endX of [-52.5, 52.5]) {
    const dir = endX > 0 ? -1 : 1;
    const paLines = [
      { w: lineW, d: 40, x: endX + dir * 16.5, z: 0 },
      { w: 16.5, d: lineW, x: endX + dir * 8.25, z: -20 },
      { w: 16.5, d: lineW, x: endX + dir * 8.25, z: 20 },
    ];
    paLines.forEach(l => {
      const geo = new THREE.PlaneGeometry(l.w, l.d);
      geo.rotateX(-Math.PI / 2);
      const line = new THREE.Mesh(geo, lineMat);
      line.position.set(l.x, 0.02, l.z);
      field.add(line);
    });
  }

  // Small building/clubhouse on the right side (visible through trees)
  const buildingGroup = new THREE.Group();
  const wallMat = new THREE.MeshStandardMaterial({ color: 0x5a3a20, roughness: 0.9 });
  const roofMat = new THREE.MeshStandardMaterial({ color: 0x3a2a1a, roughness: 0.85 });

  // Walls
  const walls = new THREE.Mesh(new THREE.BoxGeometry(8, 4, 5), wallMat);
  walls.position.y = 2;
  walls.castShadow = true;
  buildingGroup.add(walls);

  // Roof (slightly wider, sloped look via squashed box)
  const roof = new THREE.Mesh(new THREE.BoxGeometry(9, 0.8, 6), roofMat);
  roof.position.y = 4.2;
  roof.castShadow = true;
  buildingGroup.add(roof);

  // Door
  const doorMat = new THREE.MeshStandardMaterial({ color: 0x2a1a0a, roughness: 0.9 });
  const door = new THREE.Mesh(new THREE.BoxGeometry(1.2, 2.2, 0.1), doorMat);
  door.position.set(0, 1.1, 2.51);
  buildingGroup.add(door);

  // Window
  const winMat = new THREE.MeshStandardMaterial({ color: 0x7aaabb, roughness: 0.3, metalness: 0.2 });
  const win = new THREE.Mesh(new THREE.BoxGeometry(1.0, 0.8, 0.1), winMat);
  win.position.set(2.5, 2.5, 2.51);
  buildingGroup.add(win);

  const bx = 35, bz = -85;
  const by = getTerrainHeight(bx, bz);
  buildingGroup.position.set(bx, by, bz);
  buildingGroup.rotation.y = 0.3; // Slight angle
  scene.add(buildingGroup);
}

function createParkingLot() {
  // Gray asphalt parking lot to the right, near kuplahalli
  const lotGeo = new THREE.PlaneGeometry(40, 50);
  lotGeo.rotateX(-Math.PI / 2);
  const lotMat = new THREE.MeshStandardMaterial({
    color: 0x555560,
    roughness: 0.95,
    metalness: 0.0
  });
  const lot = new THREE.Mesh(lotGeo, lotMat);
  const lotZ = -108;
  const lotY = getTerrainHeight(55, lotZ) + 0.1;
  lot.position.set(55, lotY, lotZ);
  lot.receiveShadow = true;
  scene.add(lot);

  // Parking space lines
  const lineMat = new THREE.MeshStandardMaterial({ color: 0xcccccc, roughness: 0.8 });
  for (let i = 0; i < 8; i++) {
    const lineGeo = new THREE.PlaneGeometry(0.1, 5);
    lineGeo.rotateX(-Math.PI / 2);
    const line = new THREE.Mesh(lineGeo, lineMat);
    line.position.set(-15 + i * 3, 0.02, -10);
    lot.add(line);
  }
  for (let i = 0; i < 8; i++) {
    const lineGeo = new THREE.PlaneGeometry(0.1, 5);
    lineGeo.rotateX(-Math.PI / 2);
    const line = new THREE.Mesh(lineGeo, lineMat);
    line.position.set(-15 + i * 3, 0.02, 10);
    lot.add(line);
  }

  // A few parked cars (simple boxes)
  const carColors = [0x8a2020, 0x2a2a6a, 0x555555, 0x1a4a1a, 0x6a6a6a];
  const carPositions = [
    { x: -12, z: -10 }, { x: -6, z: -10 }, { x: 3, z: -10 },
    { x: -9, z: 10 }, { x: 0, z: 10 }, { x: 6, z: 10 },
  ];
  carPositions.forEach((p, i) => {
    const carGeo = new THREE.BoxGeometry(2.2, 1.3, 4.2);
    const carMat = new THREE.MeshStandardMaterial({
      color: carColors[i % carColors.length],
      roughness: 0.6,
      metalness: 0.2
    });
    const car = new THREE.Mesh(carGeo, carMat);
    car.position.set(p.x, 0.65, p.z);
    car.castShadow = true;
    lot.add(car);

    // Windshield
    const glassGeo = new THREE.BoxGeometry(1.8, 0.6, 0.1);
    const glassMat = new THREE.MeshStandardMaterial({
      color: 0x8ab8cc, roughness: 0.2, metalness: 0.3
    });
    const glass = new THREE.Mesh(glassGeo, glassMat);
    glass.position.set(p.x, 1.1, p.z - 1.2);
    lot.add(glass);
  });
}

// ============================================================
// TREE CREATION
// ============================================================
function createPineTree(height, trunkRadius, crownScale) {
  const group = new THREE.Group();

  // Trunk
  const trunkGeo = new THREE.CylinderGeometry(trunkRadius * 0.6, trunkRadius, height, 8);
  const trunkMat = new THREE.MeshStandardMaterial({
    map: createBarkTexture(),
    roughness: 0.9,
    color: 0x8a5a3a
  });
  const trunk = new THREE.Mesh(trunkGeo, trunkMat);
  trunk.position.y = height / 2;
  trunk.castShadow = true;
  group.add(trunk);

  // Crown layers (sparse scots pine canopy)
  const crownMat = new THREE.MeshStandardMaterial({
    color: 0x2a5a2a,
    roughness: 0.8,
    transparent: true,
    opacity: 0.9
  });

  const layers = 2 + Math.floor(Math.random() * 2);
  for (let i = 0; i < layers; i++) {
    const y = height * (0.78 + i * 0.08);
    const r = crownScale * (1.2 - i * 0.2) + Math.random() * 0.3;
    const coneGeo = new THREE.ConeGeometry(r, r * 0.55, 7);
    const cone = new THREE.Mesh(coneGeo, crownMat);
    cone.position.y = y;
    cone.castShadow = true;
    group.add(cone);
  }

  return group;
}

// ============================================================
// INSTANCED FOREST
// ============================================================
function createForest() {
  const barkTex = createBarkTexture();

  // Trunk instanced mesh
  const trunkGeo = new THREE.CylinderGeometry(0.06, 0.18, 14, 6);
  const trunkMat = new THREE.ShaderMaterial({
    uniforms: {
      time: { value: 0 },
      windStr: { value: 1.0 },
      barkColor: { value: new THREE.Color(0x8a5a3a) }
    },
    vertexShader: `
      uniform float time;
      uniform float windStr;
      varying vec3 vWorldPos;
      varying float vHeight;
      void main() {
        vHeight = position.y;

        // Apply instance transform
        vec4 instancePos = instanceMatrix * vec4(position, 1.0);
        vec4 worldPos = modelMatrix * instancePos;

        // Tree sway
        float sway = sin(time * 1.5 + worldPos.x * 0.5 + worldPos.z * 0.3) * 0.03;
        sway += sin(time * 2.3 + worldPos.x * 0.8) * 0.015;
        float swayAmount = max(0.0, (instancePos.y - 2.0) / 10.0);
        worldPos.x += sway * swayAmount * windStr;
        worldPos.z += sway * 0.5 * swayAmount * windStr;

        vWorldPos = worldPos.xyz;
        gl_Position = projectionMatrix * viewMatrix * worldPos;
      }
    `,
    fragmentShader: `
      uniform vec3 barkColor;
      varying float vHeight;
      void main() {
        vec3 col = barkColor;
        col += vec3(vHeight * 0.01, -vHeight * 0.005, -vHeight * 0.01);
        gl_FragColor = vec4(col, 1.0);
      }
    `
  });

  const trunkCount = 800;
  treesInstanced = new THREE.InstancedMesh(trunkGeo, trunkMat, trunkCount);
  treesInstanced.castShadow = true;

  // Crown instanced mesh
  const crownGeo = new THREE.ConeGeometry(2.2, 1.2, 6);
  const crownMat = new THREE.ShaderMaterial({
    uniforms: {
      time: { value: 0 },
      windStr: { value: 1.0 },
      leafColor: { value: new THREE.Color(0x2a5a2a) }
    },
    vertexShader: `
      uniform float time;
      uniform float windStr;
      varying vec3 vWorldPos;
      varying vec3 vNormal;
      void main() {
        // Apply instance transform
        vec4 instancePos = instanceMatrix * vec4(position, 1.0);
        vec4 worldPos = modelMatrix * instancePos;

        float sway = sin(time * 1.5 + worldPos.x * 0.5 + worldPos.z * 0.3) * 0.06;
        sway += sin(time * 2.3 + worldPos.x * 0.8) * 0.03;
        float swayAmount = max(0.0, instancePos.y) / 2.0;
        worldPos.x += sway * swayAmount * windStr;
        worldPos.z += sway * 0.5 * swayAmount * windStr;

        vWorldPos = worldPos.xyz;
        vNormal = normalize(normalMatrix * normal);
        gl_Position = projectionMatrix * viewMatrix * worldPos;
      }
    `,
    fragmentShader: `
      uniform vec3 leafColor;
      varying vec3 vNormal;
      void main() {
        vec3 col = leafColor;
        vec3 lightDir = normalize(vec3(-0.5, 1.0, -0.3));
        float diff = max(dot(vNormal, lightDir), 0.0) * 0.5 + 0.5;
        col *= diff;
        gl_FragColor = vec4(col, 1.0);
      }
    `
  });

  // Place trees (2 crowns per tree)
  const crownCount = trunkCount * 2;
  const crownInstanced = new THREE.InstancedMesh(crownGeo, crownMat, crownCount);

  const dummy = new THREE.Object3D();
  forestUsedPositions = [];

  // Keep clear zone around player and throwing lane
  function isValidTreePos(x, z, minSpacing) {
    // Clear the throwing lane
    if (Math.abs(x) < 4 && z > -80 && z < 5) return false;
    // Don't block player area
    if (Math.abs(x) < 3 && Math.abs(z) < 4) return false;
    // Don't overlap sector/obstacle trees
    if (Math.abs(x - (-10)) < 3 && Math.abs(z - (-65)) < 3) return false;
    if (Math.abs(x - 10) < 3 && Math.abs(z - (-65)) < 3) return false;
    if (Math.abs(x - 0.5) < 3 && Math.abs(z - (-35)) < 3) return false;
    // Kuplahalli exclusion zone
    if (x > 25 && x < 75 && z > -95 && z < -25) return false;
    // Football field surface only (crosswise at z=-118, ¬±52.5 x, ¬±34 z)
    if (Math.abs(x) < 55 && z < -84 && z > -152) return false;
    // Small building near field
    if (x > 30 && x < 40 && z > -90 && z < -80) return false;
    // Parking lot surface only
    if (x > 33 && x < 78 && z < -80 && z > -132) return false;
    // Check spacing
    for (const p of forestUsedPositions) {
      if (Math.hypot(x - p.x, z - p.z) < minSpacing) return false;
    }
    return true;
  }

  function placeTree(x, z) {
    const h = 14 + Math.random() * 6;
    const scale = 0.8 + Math.random() * 0.4;
    const terrainY = getTerrainHeight(x, z);

    dummy.position.set(x, terrainY + h / 2, z);
    dummy.scale.set(scale, h / 14, scale);
    dummy.updateMatrix();
    treesInstanced.setMatrixAt(placed, dummy.matrix);

    // Crown layers
    for (let c = 0; c < 2; c++) {
      const cy = terrainY + h * (0.78 + c * 0.09);
      const cs = scale * (1.0 - c * 0.2);
      dummy.position.set(x, cy, z);
      dummy.scale.set(cs, cs, cs);
      dummy.updateMatrix();
      if (placed * 2 + c < crownCount) {
        crownInstanced.setMatrixAt(placed * 2 + c, dummy.matrix);
      }
    }

    forestUsedPositions.push({ x, z });
    placed++;
  }

  let placed = 0;
  let attempts = 0;

  // Phase 1: Dense corridor trees on left/right sides (~500)
  const corridorTarget = 500;
  while (placed < corridorTarget && attempts < 10000) {
    attempts++;
    const side = Math.random() < 0.5 ? -1 : 1;
    const x = side * (5 + Math.random() * 45);
    const z = 10 - Math.random() * 95; // z from +10 to -85

    if (!isValidTreePos(x, z, 2)) continue;
    placeTree(x, z);
  }

  // Phase 2: Background radial fill (~300)
  while (placed < trunkCount && attempts < 18000) {
    attempts++;
    const angle = Math.random() * Math.PI * 2;
    const dist = 8 + Math.random() * 85;
    const x = Math.cos(angle) * dist;
    const z = Math.sin(angle) * dist - 20;

    if (!isValidTreePos(x, z, 3)) continue;
    placeTree(x, z);
  }

  treesInstanced.count = placed;
  crownInstanced.count = placed * 2;
  treesInstanced.instanceMatrix.needsUpdate = true;
  crownInstanced.instanceMatrix.needsUpdate = true;

  scene.add(treesInstanced);
  scene.add(crownInstanced);

  // Store crown instanced for updates
  treesInstanced.userData.crownMesh = crownInstanced;
}

// ============================================================
// BIRCH TREES (Golden autumn mix)
// ============================================================
function createBirchTrees() {
  const birchCount = 120;

  // Trunk geometry & shader (white/cream bark with dark bands)
  const trunkGeo = new THREE.CylinderGeometry(0.05, 0.1, 12, 6);
  const trunkMat = new THREE.ShaderMaterial({
    uniforms: {
      time: { value: 0 },
      windStr: { value: 1.0 },
      barkColor: { value: new THREE.Color(0xd4ccbb) }
    },
    vertexShader: `
      uniform float time;
      uniform float windStr;
      varying vec3 vWorldPos;
      varying float vHeight;
      void main() {
        vHeight = position.y;
        // Apply instance transform
        vec4 instancePos = instanceMatrix * vec4(position, 1.0);
        vec4 worldPos = modelMatrix * instancePos;
        float sway = sin(time * 1.8 + worldPos.x * 0.6 + worldPos.z * 0.4) * 0.04;
        sway += sin(time * 2.5 + worldPos.x * 0.9) * 0.02;
        float swayAmount = max(0.0, (instancePos.y - 2.0) / 10.0);
        worldPos.x += sway * swayAmount * windStr;
        worldPos.z += sway * 0.5 * swayAmount * windStr;
        vWorldPos = worldPos.xyz;
        gl_Position = projectionMatrix * viewMatrix * worldPos;
      }
    `,
    fragmentShader: `
      uniform vec3 barkColor;
      varying float vHeight;
      void main() {
        vec3 col = barkColor;
        // Birch bark dark horizontal bands
        float band = step(0.85, fract(vHeight * 2.5 + sin(vHeight * 8.0) * 0.1));
        col = mix(col, vec3(0.25, 0.22, 0.18), band * 0.6);
        col += vec3(vHeight * 0.005, -vHeight * 0.003, -vHeight * 0.005);
        gl_FragColor = vec4(col, 1.0);
      }
    `
  });

  birchInstanced = new THREE.InstancedMesh(trunkGeo, trunkMat, birchCount);
  birchInstanced.castShadow = true;

  // Crown geometry & shader (round golden canopy)
  const crownGeo = new THREE.SphereGeometry(1.0, 6, 5);
  const crownMat = new THREE.ShaderMaterial({
    uniforms: {
      time: { value: 0 },
      windStr: { value: 1.0 },
      leafColor: { value: new THREE.Color(0xb8922a) }
    },
    vertexShader: `
      uniform float time;
      uniform float windStr;
      varying vec3 vWorldPos;
      varying vec3 vNormal;
      void main() {
        // Apply instance transform
        vec4 instancePos = instanceMatrix * vec4(position, 1.0);
        vec4 worldPos = modelMatrix * instancePos;
        float sway = sin(time * 1.8 + worldPos.x * 0.6 + worldPos.z * 0.4) * 0.08;
        sway += sin(time * 2.5 + worldPos.x * 0.9) * 0.04;
        float swayAmount = max(0.0, instancePos.y) / 1.5;
        worldPos.x += sway * swayAmount * windStr;
        worldPos.z += sway * 0.5 * swayAmount * windStr;
        vWorldPos = worldPos.xyz;
        vNormal = normalize(normalMatrix * normal);
        gl_Position = projectionMatrix * viewMatrix * worldPos;
      }
    `,
    fragmentShader: `
      uniform vec3 leafColor;
      varying vec3 vNormal;
      void main() {
        vec3 col = leafColor;
        vec3 lightDir = normalize(vec3(-0.5, 1.0, -0.3));
        float diff = max(dot(vNormal, lightDir), 0.0) * 0.5 + 0.5;
        col *= diff;
        gl_FragColor = vec4(col, 1.0);
      }
    `
  });

  const crownCount = birchCount;
  const crownInstanced = new THREE.InstancedMesh(crownGeo, crownMat, crownCount);

  const dummy = new THREE.Object3D();
  let placed = 0;
  let attempts = 0;

  while (placed < birchCount && attempts < 3000) {
    attempts++;
    const side = Math.random() < 0.5 ? -1 : 1;
    const x = side * (15 + Math.random() * 35);
    const z = -10 - Math.random() * 70; // z from -10 to -80

    // Check spacing against existing forest trees and other birches
    let tooClose = false;
    for (const p of forestUsedPositions) {
      if (Math.hypot(x - p.x, z - p.z) < 4) { tooClose = true; break; }
    }
    if (tooClose) continue;

    // Avoid throwing lane, player area, kuplahalli
    if (Math.abs(x) < 4 && z > -80 && z < 5) continue;
    if (Math.abs(x) < 3 && Math.abs(z) < 4) continue;
    if (x > 25 && x < 75 && z > -95 && z < -25) continue;

    const h = 8 + Math.random() * 6; // 8-14m
    const scale = 0.7 + Math.random() * 0.4;
    const terrainY = getTerrainHeight(x, z);

    // Trunk
    dummy.position.set(x, terrainY + h / 2, z);
    dummy.scale.set(scale, h / 12, scale);
    dummy.updateMatrix();
    birchInstanced.setMatrixAt(placed, dummy.matrix);

    // Crown at 60-75% height
    const crownY = terrainY + h * (0.60 + Math.random() * 0.15);
    const cs = scale * (1.2 + Math.random() * 0.3);
    dummy.position.set(x, crownY, z);
    dummy.scale.set(cs, cs * 0.8, cs);
    dummy.updateMatrix();
    crownInstanced.setMatrixAt(placed, dummy.matrix);

    forestUsedPositions.push({ x, z });
    placed++;
  }

  birchInstanced.count = placed;
  crownInstanced.count = placed;
  birchInstanced.instanceMatrix.needsUpdate = true;
  crownInstanced.instanceMatrix.needsUpdate = true;

  scene.add(birchInstanced);
  scene.add(crownInstanced);

  birchInstanced.userData.crownMesh = crownInstanced;
}

// ============================================================
// SECTOR TREES + OBSTACLE
// ============================================================
function createSectorTrees() {
  // Left sector pine
  sectorLeftPine = createPineTree(16, 0.3, 2.5);
  sectorLeftPine.position.set(-10, getTerrainHeight(-10, -65), -65);
  scene.add(sectorLeftPine);

  // Right sector pine
  sectorRightPine = createPineTree(16, 0.3, 2.5);
  sectorRightPine.position.set(10, getTerrainHeight(10, -65), -65);
  scene.add(sectorRightPine);

  // Obstacle pine in the middle - slightly different (birch-like)
  const obstGroup = new THREE.Group();

  // White-ish trunk (birch)
  const trunkGeo = new THREE.CylinderGeometry(0.15, 0.25, 14, 8);
  const trunkMat = new THREE.MeshStandardMaterial({
    color: 0xccbbaa,
    roughness: 0.7
  });
  const trunk = new THREE.Mesh(trunkGeo, trunkMat);
  trunk.position.y = 7;
  trunk.castShadow = true;
  obstGroup.add(trunk);

  // Some tape/marking
  const tapeGeo = new THREE.CylinderGeometry(0.27, 0.27, 0.3, 8);
  const tapeMat = new THREE.MeshStandardMaterial({ color: 0xff4444, roughness: 0.5 });
  const tape = new THREE.Mesh(tapeGeo, tapeMat);
  tape.position.y = 3;
  obstGroup.add(tape);

  // Crown
  const crownMat = new THREE.MeshStandardMaterial({
    color: 0x4a7a3a, roughness: 0.8
  });
  for (let i = 0; i < 3; i++) {
    const coneGeo = new THREE.ConeGeometry(1.8 - i * 0.3, 2.5, 7);
    const cone = new THREE.Mesh(coneGeo, crownMat);
    cone.position.y = 10 + i * 2;
    cone.castShadow = true;
    obstGroup.add(cone);
  }

  obstGroup.position.set(0.5, getTerrainHeight(0.5, -35), -35);
  obstaclePine = obstGroup;
  obstaclePine.userData.radius = 0.8; // collision radius
  scene.add(obstaclePine);
}

// ============================================================
// FOUL LINE (Pine Root)
// ============================================================
function createFoulLine() {
  const rootMat = new THREE.MeshStandardMaterial({
    color: 0x5a3a1a,
    roughness: 0.95
  });

  // Main root
  const th0 = getTerrainHeight(0, 1);
  const curve = new THREE.CatmullRomCurve3([
    new THREE.Vector3(-2, getTerrainHeight(-2, 1) + 0.05, 1),
    new THREE.Vector3(-1, getTerrainHeight(-1, 0.9) + 0.15, 0.9),
    new THREE.Vector3(0, th0 + 0.2, 0.85),
    new THREE.Vector3(1, getTerrainHeight(1, 0.95) + 0.15, 0.95),
    new THREE.Vector3(2, getTerrainHeight(2, 1) + 0.05, 1),
  ]);
  const rootGeo = new THREE.TubeGeometry(curve, 20, 0.08, 6, false);
  const root = new THREE.Mesh(rootGeo, rootMat);
  root.castShadow = true;
  scene.add(root);

  // Branch roots
  for (let i = 0; i < 4; i++) {
    const sx = -1.5 + i;
    const bz1 = 0.5 + Math.random() * 0.3;
    const bz2 = 0.2 + Math.random() * 0.2;
    const curve2 = new THREE.CatmullRomCurve3([
      new THREE.Vector3(sx, getTerrainHeight(sx, 0.9) + 0.12, 0.9),
      new THREE.Vector3(sx + 0.3, getTerrainHeight(sx + 0.3, bz1) + 0.08, bz1),
      new THREE.Vector3(sx + 0.5, getTerrainHeight(sx + 0.5, bz2) + 0.02, bz2),
    ]);
    const brGeo = new THREE.TubeGeometry(curve2, 8, 0.04, 5, false);
    scene.add(new THREE.Mesh(brGeo, rootMat));
  }
}

// ============================================================
// THROWING BOULDER
// ============================================================
function createThrowingBoulder() {
  const boulderGeo = new THREE.DodecahedronGeometry(1.2, 1);
  // Displace vertices for irregular shape
  const pos = boulderGeo.attributes.position;
  for (let i = 0; i < pos.count; i++) {
    const x = pos.getX(i), y = pos.getY(i), z = pos.getZ(i);
    const disp = Math.sin(x * 3.1) * 0.15 + Math.sin(y * 2.7 + z * 1.8) * 0.1 + Math.sin(z * 4.2) * 0.08;
    pos.setX(i, x + disp * x * 0.3);
    pos.setY(i, y * 0.7 + disp * y * 0.2); // Y-squash for flattened look
    pos.setZ(i, z + disp * z * 0.3);
  }
  boulderGeo.computeVertexNormals();

  const boulderMat = new THREE.MeshStandardMaterial({
    color: 0x888880,
    roughness: 0.92,
    metalness: 0.05
  });

  const boulder = new THREE.Mesh(boulderGeo, boulderMat);
  const ty = getTerrainHeight(0, 0.5);
  boulder.position.set(-2.4, ty + 0.3, -3.5);
  boulder.rotation.set(0.15, 0.4, 0.1); // Slight random tilt
  boulder.castShadow = true;
  boulder.receiveShadow = true;
  scene.add(boulder);
}

// ============================================================
// GROUND ROCKS
// ============================================================
function createGroundRocks() {
  const rockGeo = new THREE.DodecahedronGeometry(0.5, 0);
  // Displace vertices for natural look
  const pos = rockGeo.attributes.position;
  for (let i = 0; i < pos.count; i++) {
    const x = pos.getX(i), y = pos.getY(i), z = pos.getZ(i);
    const disp = Math.sin(x * 5.3) * 0.12 + Math.sin(y * 3.7 + z * 2.1) * 0.08;
    pos.setX(i, x + disp * 0.3);
    pos.setY(i, y * 0.7 + disp * 0.2); // Y-squash
    pos.setZ(i, z + disp * 0.3);
  }
  rockGeo.computeVertexNormals();

  const rockMat = new THREE.MeshStandardMaterial({
    color: 0x7a7a72,
    roughness: 0.95,
    metalness: 0.0
  });

  const rockCount = 40;
  const rockMesh = new THREE.InstancedMesh(rockGeo, rockMat, rockCount);
  rockMesh.castShadow = true;
  rockMesh.receiveShadow = true;

  const dummy = new THREE.Object3D();
  let placed = 0;

  for (let i = 0; i < 200 && placed < rockCount; i++) {
    const x = (Math.random() - 0.5) * 80;
    const z = -Math.random() * 80;

    // Avoid throwing lane
    if (Math.abs(x) < 4 && z > -80 && z < 5) continue;
    // Avoid player area
    if (Math.abs(x) < 3 && Math.abs(z) < 4) continue;
    // Avoid kuplahalli area
    if (x > 25 && x < 75 && z > -95 && z < -25) continue;

    const scale = 0.15 + Math.random() * 0.45;
    const ty = getTerrainHeight(x, z);
    dummy.position.set(x, ty + scale * 0.2, z);
    dummy.scale.set(scale, scale, scale);
    dummy.rotation.set(Math.random() * 0.5, Math.random() * Math.PI * 2, Math.random() * 0.5);
    dummy.updateMatrix();
    rockMesh.setMatrixAt(placed, dummy.matrix);
    placed++;
  }

  rockMesh.count = placed;
  rockMesh.instanceMatrix.needsUpdate = true;
  scene.add(rockMesh);
}

// ============================================================
// NPC CREATION
// ============================================================
function createHumanoid(color, headColor, options = {}) {
  const group = new THREE.Group();

  // Body
  const bodyGeo = new THREE.CylinderGeometry(0.2, 0.25, 0.8, 6);
  const bodyMat = new THREE.MeshStandardMaterial({ color, roughness: 0.8 });
  const body = new THREE.Mesh(bodyGeo, bodyMat);
  body.position.y = 1.1;
  group.add(body);

  // Track jacket stripes
  if (options.stripe !== false && options.stripeColor) {
    const stripeMat = new THREE.MeshStandardMaterial({ color: options.stripeColor, roughness: 0.7 });
    const stripeGeo = new THREE.CylinderGeometry(0.215, 0.215, 0.04, 6);
    const stripe1 = new THREE.Mesh(stripeGeo, stripeMat);
    stripe1.position.y = 1.2;
    group.add(stripe1);
    const stripe2 = new THREE.Mesh(stripeGeo, stripeMat);
    stripe2.position.y = 1.05;
    group.add(stripe2);
  }

  // Head
  const headGeo = new THREE.SphereGeometry(0.15, 8, 6);
  const headMat = new THREE.MeshStandardMaterial({ color: headColor || 0xd4a574, roughness: 0.7 });
  const head = new THREE.Mesh(headGeo, headMat);
  head.position.y = 1.65;
  group.add(head);

  // Beanie
  if (options.beanie !== false && options.beanieColor !== undefined) {
    const beanieGeo = new THREE.SphereGeometry(0.16, 8, 5, 0, Math.PI * 2, 0, Math.PI * 0.55);
    const beanieMat = new THREE.MeshStandardMaterial({ color: options.beanieColor, roughness: 0.85 });
    const beanie = new THREE.Mesh(beanieGeo, beanieMat);
    beanie.position.y = 1.68;
    group.add(beanie);
  }

  // Legs (dark pants)
  const legGeo = new THREE.CylinderGeometry(0.07, 0.08, 0.7, 5);
  const legMat = new THREE.MeshStandardMaterial({ color: 0x1a1a2a, roughness: 0.8 });
  const legL = new THREE.Mesh(legGeo, legMat);
  legL.position.set(-0.1, 0.35, 0);
  group.add(legL);
  const legR = new THREE.Mesh(legGeo, legMat);
  legR.position.set(0.1, 0.35, 0);
  group.add(legR);

  // Arms (invisible containers ‚Äî keep for animation targets and javelin parenting)
  const armL = new THREE.Object3D();
  armL.position.set(-0.3, 1.1, 0);
  armL.rotation.z = 0.15;
  group.add(armL);
  const armR = new THREE.Object3D();
  armR.position.set(0.3, 1.1, 0);
  armR.rotation.z = -0.15;
  group.add(armR);

  group.userData.armL = armL;
  group.userData.armR = armR;
  group.userData.legL = legL;
  group.userData.legR = legR;
  group.userData.animPhase = Math.random() * Math.PI * 2;
  group.userData.reaction = 'idle';
  group.userData.reactionTimer = 0;

  group.castShadow = true;
  return group;
}

function createNPCs() {
  const darkPalette = [0x1a1a1a, 0x1a1a2a, 0x2a2a2a, 0x222222, 0x1a2a1a, 0x0a0a1a, 0x2a2a3a];
  const beanieColors = [0x1a1a1a, 0x2a2a2a, 0x1a1a3a, 0x3a1a1a, 0x1a2a1a, 0x2a1a2a];

  const npcDefs = [
    { name: 'Coach Matti', color: 0x2a3a2a, opts: { beanieColor: 0x2a2a2a }, finalX: -3, finalZ: 0, finalRotY: 0.5 },
    { name: 'Spectator', color: darkPalette[0], opts: { beanieColor: beanieColors[0], stripeColor: 0xdddddd }, finalX: 4, finalZ: -0.5 },
    { name: 'Spectator', color: darkPalette[1], opts: { beanieColor: beanieColors[1] }, finalX: 4.6, finalZ: -1.5 },
    { name: 'Spectator', color: darkPalette[2], opts: { beanieColor: beanieColors[2], stripeColor: 0xdddddd }, finalX: 5.2, finalZ: -2.5 },
    { name: 'Spectator', color: darkPalette[3], opts: { beanieColor: beanieColors[3] }, finalX: 4.3, finalZ: -3.2 },
    { name: 'Spectator', color: darkPalette[4], opts: { stripeColor: 0xcccccc }, finalX: 5.5, finalZ: -3.8 },
    { name: 'Spectator', color: darkPalette[5], opts: { beanieColor: beanieColors[4], stripeColor: 0xdddddd }, finalX: -3.5, finalZ: -1.5 },
    { name: 'Spectator', color: darkPalette[6], opts: { beanieColor: beanieColors[5] }, finalX: -4.2, finalZ: -2.8 },
    { name: 'Spectator', color: darkPalette[0], opts: { beanieColor: beanieColors[0] }, finalX: -5.0, finalZ: -3.8 },
    { name: 'Spectator', color: darkPalette[1], opts: { beanieColor: beanieColors[1], stripeColor: 0xdddddd }, finalX: -4.6, finalZ: -5.0 },
    { name: 'Spectator', color: darkPalette[2], opts: { beanieColor: beanieColors[2] }, finalX: 5.8, finalZ: -8 },
    { name: 'Spectator', color: darkPalette[3], opts: { beanieColor: beanieColors[3], stripeColor: 0xcccccc }, finalX: 6.5, finalZ: -9 },
    { name: 'Spectator', color: darkPalette[4], opts: { beanieColor: beanieColors[4] }, finalX: 6.8, finalZ: -10 },
    { name: 'Spectator', color: darkPalette[5], opts: { beanieColor: beanieColors[5], stripeColor: 0xdddddd }, finalX: -6, finalZ: -8 },
    { name: 'Spectator', color: darkPalette[6], opts: { beanieColor: beanieColors[0] }, finalX: 3.5, finalZ: -6 },
    { name: 'Spectator', color: darkPalette[0], opts: { beanieColor: beanieColors[1], stripeColor: 0xcccccc }, finalX: -2.5, finalZ: -6.5 },
    { name: 'Jukka', color: 0x2a1a1a, opts: { beanieColor: 0x1a1a1a, stripeColor: 0xdddddd }, finalX: -7, finalZ: -20, finalRotY: 1 },
    { name: 'Heikki', color: 0x1a2a3a, opts: { beanieColor: 0x2a2a3a }, finalX: 7, finalZ: -25, finalRotY: -1 },
  ];

  const count = npcDefs.length;
  for (let i = 0; i < count; i++) {
    const def = npcDefs[i];
    const npc = createHumanoid(def.color, undefined, def.opts || {});

    // Gathered position: semicircle in front of player
    let gx, gz;
    if (def.name === 'Coach Matti') {
      gx = 0;
      gz = -2.5;
    } else {
      const angle = -Math.PI / 2 + (Math.PI * (i / (count - 1)));
      const radius = 2.5 + (i % 2) * 0.8;
      gx = Math.sin(angle) * radius;
      gz = -1 + Math.cos(angle) * radius * -1;
    }

    const gy = getTerrainHeight(gx, gz);
    npc.position.set(gx, gy, gz);
    npc.rotation.y = Math.atan2(-gx, 1);
    npc.userData.name = def.name;
    npc.userData.baseY = gy;

    npc.userData.gatheredPos = { x: gx, z: gz };
    npc.userData.finalPos = { x: def.finalX, z: def.finalZ };
    npc.userData.finalRotY = def.finalRotY !== undefined ? def.finalRotY : Math.atan2(-def.finalX, -def.finalZ - 10);

    scene.add(npc);
    npcMeshes.push(npc);
  }
}

// ============================================================
// PARTICLES - FALLING LEAVES
// ============================================================
function createLeafParticles() {
  const count = 200;
  const geo = new THREE.BufferGeometry();
  const positions = new Float32Array(count * 3);
  const velocities = [];

  for (let i = 0; i < count; i++) {
    positions[i * 3] = (Math.random() - 0.5) * 80;
    positions[i * 3 + 1] = 5 + Math.random() * 15;
    positions[i * 3 + 2] = (Math.random() - 0.5) * 80 - 20;
    velocities.push({
      x: (Math.random() - 0.5) * 0.5,
      y: -0.3 - Math.random() * 0.5,
      z: (Math.random() - 0.5) * 0.5,
      phase: Math.random() * Math.PI * 2,
      speed: 0.5 + Math.random() * 1.5
    });
  }

  geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));

  const mat = new THREE.PointsMaterial({
    size: 0.15,
    color: 0xCC7722,
    transparent: true,
    opacity: 0.8,
    sizeAttenuation: true
  });

  leafParticles = new THREE.Points(geo, mat);
  leafParticles.userData.velocities = velocities;
  scene.add(leafParticles);
}

// ============================================================
// WIND PARTICLES
// ============================================================
function createWindParticles() {
  const count = 100;
  const geo = new THREE.BufferGeometry();
  const positions = new Float32Array(count * 3);

  for (let i = 0; i < count; i++) {
    positions[i * 3] = (Math.random() - 0.5) * 60;
    positions[i * 3 + 1] = 0.2 + Math.random() * 2;
    positions[i * 3 + 2] = (Math.random() - 0.5) * 60 - 20;
  }

  geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
  const mat = new THREE.PointsMaterial({
    size: 0.06,
    color: 0xaa8855,
    transparent: true,
    opacity: 0.4,
    sizeAttenuation: true
  });

  windParticles = new THREE.Points(geo, mat);
  scene.add(windParticles);
}

// ============================================================
// BIRD PARTICLES
// ============================================================
function createBirdParticles() {
  const count = 15;
  const geo = new THREE.BufferGeometry();
  const positions = new Float32Array(count * 3);

  for (let i = 0; i < count; i++) {
    positions[i * 3] = (Math.random() - 0.5) * 80;
    positions[i * 3 + 1] = 18 + Math.random() * 10;
    positions[i * 3 + 2] = (Math.random() - 0.5) * 80 - 20;
  }

  geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
  const mat = new THREE.PointsMaterial({
    size: 0.2,
    color: 0x2a2a2a,
    sizeAttenuation: true
  });

  birdParticles = new THREE.Points(geo, mat);
  birdParticles.userData.centers = [];
  birdParticles.userData.phases = [];
  for (let i = 0; i < count; i++) {
    birdParticles.userData.centers.push({
      x: positions[i * 3],
      y: positions[i * 3 + 1],
      z: positions[i * 3 + 2]
    });
    birdParticles.userData.phases.push(Math.random() * Math.PI * 2);
  }
  scene.add(birdParticles);
}

// ============================================================
// PLAYER ARM
// ============================================================
function createPlayerArm() {
  armGroup = new THREE.Group();

  // Materials ‚Äî blue jacket sleeve, warm skin, subtle nail
  const skinMat = new THREE.MeshStandardMaterial({ color: 0xd4a574, roughness: 0.6, metalness: 0.05 });
  const skinDarkMat = new THREE.MeshStandardMaterial({ color: 0xc49464, roughness: 0.65, metalness: 0.05 });
  const sleeveMat = new THREE.MeshStandardMaterial({ color: 0x4a6fa0, roughness: 0.75 });
  const sleeveCuffMat = new THREE.MeshStandardMaterial({ color: 0x3d5c85, roughness: 0.8 });
  const nailMat = new THREE.MeshStandardMaterial({ color: 0xf0c8b0, roughness: 0.3, metalness: 0.1 });

  // --- UPPER ARM (blue jacket sleeve) ---
  const upperArm = new THREE.Group();
  upperArm.name = 'upperArm';

  // Shoulder cap
  const shoulderCap = new THREE.Mesh(
    new THREE.SphereGeometry(0.065, 12, 8, 0, Math.PI * 2, 0, Math.PI / 2),
    sleeveMat
  );
  shoulderCap.position.set(0, 0.02, 0);
  upperArm.add(shoulderCap);

  // Main upper arm cylinder
  const upperArmMesh = new THREE.Mesh(
    new THREE.CylinderGeometry(0.055, 0.06, 0.38, 12),
    sleeveMat
  );
  upperArmMesh.position.set(0, -0.17, 0);
  upperArm.add(upperArmMesh);

  // Sleeve cuff at elbow
  const cuff = new THREE.Mesh(
    new THREE.CylinderGeometry(0.062, 0.058, 0.04, 12),
    sleeveCuffMat
  );
  cuff.position.set(0, -0.36, 0);
  upperArm.add(cuff);

  // Sleeve fold detail
  const fold1 = new THREE.Mesh(
    new THREE.TorusGeometry(0.058, 0.005, 6, 12),
    sleeveCuffMat
  );
  fold1.position.set(0, -0.34, 0);
  fold1.rotation.x = Math.PI / 2;
  upperArm.add(fold1);

  upperArm.position.set(0, -0.15, 0);

  // --- ELBOW JOINT ---
  const elbow = new THREE.Mesh(
    new THREE.SphereGeometry(0.05, 10, 10),
    skinMat
  );
  elbow.name = 'elbow';
  elbow.position.set(0, -0.38, 0.02);
  elbow.scale.set(1, 0.85, 1.1);
  armGroup.add(elbow);

  // --- FOREARM (exposed skin) ---
  const forearm = new THREE.Group();
  forearm.name = 'forearm';

  // Main forearm ‚Äî tapered, slightly wider near elbow
  const forearmMesh = new THREE.Mesh(
    new THREE.CylinderGeometry(0.035, 0.048, 0.32, 12),
    skinMat
  );
  forearmMesh.position.set(0, -0.14, 0);
  forearm.add(forearmMesh);

  // Subtle muscle bulge on forearm
  const muscleBulge = new THREE.Mesh(
    new THREE.SphereGeometry(0.03, 8, 8),
    skinMat
  );
  muscleBulge.position.set(0.015, -0.08, -0.015);
  muscleBulge.scale.set(1.2, 1.8, 0.8);
  forearm.add(muscleBulge);

  // Wrist ‚Äî narrower
  const wrist = new THREE.Mesh(
    new THREE.CylinderGeometry(0.03, 0.035, 0.06, 10),
    skinMat
  );
  wrist.position.set(0, -0.31, 0.02);
  forearm.add(wrist);

  // Wrist bone bumps (ulna/radius)
  const wristBoneL = new THREE.Mesh(
    new THREE.SphereGeometry(0.012, 6, 6),
    skinDarkMat
  );
  wristBoneL.position.set(-0.03, -0.3, 0.02);
  forearm.add(wristBoneL);
  const wristBoneR = new THREE.Mesh(
    new THREE.SphereGeometry(0.01, 6, 6),
    skinDarkMat
  );
  wristBoneR.position.set(0.03, -0.3, 0.02);
  forearm.add(wristBoneR);

  forearm.position.set(0, -0.32, 0.05);

  // --- HAND (gripping pose ‚Äî fingers wrap around held object) ---
  const hand = new THREE.Group();
  hand.name = 'hand';

  // Grip center ‚Äî where the held object's shaft sits
  const gripY = 0;
  const gripZ = 0;
  const gripRadius = 0.035; // radius of the cylindrical grip space

  // Palm ‚Äî behind the grip, slightly cupped
  const palm = new THREE.Mesh(
    new THREE.BoxGeometry(0.09, 0.11, 0.03),
    skinMat
  );
  palm.position.set(0, gripY, gripZ - 0.04);
  hand.add(palm);

  // Palm pad (fleshy inner surface facing object)
  const palmPad = new THREE.Mesh(
    new THREE.BoxGeometry(0.08, 0.09, 0.012),
    skinDarkMat
  );
  palmPad.position.set(0, gripY, gripZ - 0.02);
  hand.add(palmPad);

  // Knuckle ridge across top of palm
  for (let i = 0; i < 4; i++) {
    const knuckle = new THREE.Mesh(
      new THREE.SphereGeometry(0.014, 8, 8),
      skinDarkMat
    );
    knuckle.position.set(-0.03 + i * 0.02, gripY + 0.055, gripZ - 0.03);
    hand.add(knuckle);
  }

  // Helper: create a curling finger segment along an arc
  function createGripFinger(totalLen, baseR, tipR, curlAngle) {
    const finger = new THREE.Group();
    const segments = 3;
    const segLens = [totalLen * 0.45, totalLen * 0.3, totalLen * 0.25];
    const segRadii = [
      [baseR, baseR * 0.9],
      [baseR * 0.9, tipR + 0.002],
      [tipR + 0.002, tipR * 0.8]
    ];
    const curlPerSeg = curlAngle / segments;

    let cursor = new THREE.Group();
    finger.add(cursor);

    for (let s = 0; s < segments; s++) {
      // Segment cylinder
      const seg = new THREE.Mesh(
        new THREE.CylinderGeometry(segRadii[s][1], segRadii[s][0], segLens[s], 8),
        skinMat
      );
      seg.position.set(0, segLens[s] / 2, 0);
      cursor.add(seg);

      // Joint sphere between segments
      if (s < segments - 1) {
        const joint = new THREE.Mesh(
          new THREE.SphereGeometry(segRadii[s][1] * 1.05, 6, 6),
          skinDarkMat
        );
        joint.position.set(0, segLens[s], 0);
        cursor.add(joint);
      }

      // Fingernail on last segment
      if (s === segments - 1) {
        const nail = new THREE.Mesh(
          new THREE.BoxGeometry(tipR * 2.0, segLens[s] * 0.45, 0.005),
          nailMat
        );
        nail.position.set(0, segLens[s] * 0.7, -tipR * 0.7);
        cursor.add(nail);
      }

      // Advance cursor ‚Äî rotate to curl, then move to end of segment
      if (s < segments - 1) {
        const nextCursor = new THREE.Group();
        nextCursor.position.set(0, segLens[s], 0);
        nextCursor.rotation.x = curlPerSeg;
        cursor.add(nextCursor);
        cursor = nextCursor;
      }
    }

    return finger;
  }

  // Four fingers ‚Äî positioned at knuckles, curling forward and around grip
  const fingerSpecs = [
    { x: -0.03, len: 0.09, baseR: 0.012, tipR: 0.009, curl: 2.6 },   // index
    { x: -0.01, len: 0.10, baseR: 0.012, tipR: 0.009, curl: 2.7 },   // middle
    { x:  0.01, len: 0.09, baseR: 0.012, tipR: 0.009, curl: 2.7 },   // ring
    { x:  0.028, len: 0.075, baseR: 0.010, tipR: 0.008, curl: 2.8 }, // pinky
  ];

  fingerSpecs.forEach((spec, i) => {
    const finger = createGripFinger(spec.len, spec.baseR, spec.tipR, spec.curl);
    // Start from knuckle row, pointing up, then curling over and around
    finger.position.set(spec.x, gripY + 0.055, gripZ - 0.03);
    // Initial angle: fingers point forward-up then curl over the object
    finger.rotation.x = -0.3;
    finger.rotation.z = (i - 1.5) * 0.02;
    hand.add(finger);
  });

  // Thumb ‚Äî on the left side (near side), opposing the fingers
  const thumb = new THREE.Group();

  const thumbMetacarpal = new THREE.Mesh(
    new THREE.CylinderGeometry(0.016, 0.019, 0.05, 8),
    skinMat
  );
  thumbMetacarpal.position.set(0, 0.025, 0);
  thumb.add(thumbMetacarpal);

  const thumbJoint1 = new THREE.Mesh(
    new THREE.SphereGeometry(0.016, 6, 6),
    skinDarkMat
  );
  thumbJoint1.position.set(0, 0.05, 0);
  thumb.add(thumbJoint1);

  const thumbProximal = new THREE.Mesh(
    new THREE.CylinderGeometry(0.014, 0.016, 0.04, 8),
    skinMat
  );
  thumbProximal.position.set(0, 0.075, 0.01);
  thumbProximal.rotation.x = 0.3;
  thumb.add(thumbProximal);

  const thumbJoint2 = new THREE.Mesh(
    new THREE.SphereGeometry(0.013, 6, 6),
    skinDarkMat
  );
  thumbJoint2.position.set(0, 0.095, 0.02);
  thumb.add(thumbJoint2);

  const thumbDistal = new THREE.Mesh(
    new THREE.CylinderGeometry(0.011, 0.014, 0.03, 8),
    skinMat
  );
  thumbDistal.position.set(0, 0.115, 0.035);
  thumbDistal.rotation.x = 0.5;
  thumb.add(thumbDistal);

  const thumbNail = new THREE.Mesh(
    new THREE.BoxGeometry(0.016, 0.018, 0.005),
    nailMat
  );
  thumbNail.position.set(0, 0.13, 0.03);
  thumb.add(thumbNail);

  // Position thumb: left side of palm, angled to press against object
  thumb.position.set(-0.055, gripY - 0.03, gripZ - 0.01);
  thumb.rotation.set(0.2, 0, 0.8);
  hand.add(thumb);

  // Thenar eminence (fleshy thumb-side pad)
  const thenar = new THREE.Mesh(
    new THREE.SphereGeometry(0.025, 8, 8),
    skinMat
  );
  thenar.position.set(-0.04, gripY - 0.01, gripZ - 0.03);
  thenar.scale.set(0.8, 1.2, 0.7);
  hand.add(thenar);

  // Position hand at grip point on the arm, palm facing left (natural right-hand grip)
  hand.position.set(0, -0.48, 0.1);
  hand.rotation.y = Math.PI / 2;

  // --- JAVELIN in hand (will be toggled) ---
  const stickInHand = createJavelinMesh();
  stickInHand.name = 'stickInHand';
  stickInHand.rotation.x = Math.PI / 2;
  stickInHand.position.set(0, -0.48, 0.1);
  stickInHand.scale.set(0.5, 0.5, 0.5);

  // --- BOTTLE in hand (child of hand group, hidden by default) ---
  const bottleInHand = createBottleMesh();
  bottleInHand.name = 'bottleInHand';
  bottleInHand.position.set(0, -0.1, 0); // centered in hand grip
  bottleInHand.rotation.y = 0.4; // tilt cap toward mouth, bottom faces forward
  bottleInHand.visible = false;
  hand.add(bottleInHand); // bottle moves with hand as one unit

  // --- BEER CAN in hand (hidden by default) ---
  const beerCanInHand = createBeerCanMesh();
  beerCanInHand.name = 'beerCanInHand';
  beerCanInHand.position.set(0, -0.1, 0);
  beerCanInHand.rotation.y = 0.4;
  beerCanInHand.visible = false;
  hand.add(beerCanInHand);

  // --- DICE in hand (hidden by default) ---
  const diceInHand = createDiceInHandMesh();
  diceInHand.name = 'diceInHand';
  diceInHand.position.set(0, -0.1, 0);
  diceInHand.visible = false;
  hand.add(diceInHand);

  // Assemble
  armGroup.add(upperArm);
  armGroup.add(forearm);
  armGroup.add(hand);
  armGroup.add(stickInHand);

  // Position relative to camera
  armGroup.position.set(0.35, -0.3, -0.5);
  camera.add(armGroup);
  scene.add(camera);
}

function createJavelinMesh() {
  const group = new THREE.Group();
  const stickMat = new THREE.MeshStandardMaterial({ color: 0x8B6914, roughness: 0.85 });

  // Main shaft - slightly tapered
  const shaft = new THREE.Mesh(
    new THREE.CylinderGeometry(0.015, 0.02, 1.8, 6),
    stickMat
  );
  shaft.rotation.x = Math.PI / 2;
  group.add(shaft);

  // Slight bend (extra cylinder offset)
  const bend = new THREE.Mesh(
    new THREE.CylinderGeometry(0.016, 0.016, 0.4, 5),
    stickMat
  );
  bend.position.set(0.005, 0, -0.3);
  bend.rotation.x = Math.PI / 2 + 0.03;
  group.add(bend);

  // Carved tip
  const tip = new THREE.Mesh(
    new THREE.ConeGeometry(0.018, 0.12, 5),
    new THREE.MeshStandardMaterial({ color: 0xBB9944, roughness: 0.7 })
  );
  tip.rotation.x = -Math.PI / 2;
  tip.position.z = -0.96;
  group.add(tip);

  // Grip wrap
  const grip = new THREE.Mesh(
    new THREE.CylinderGeometry(0.022, 0.022, 0.2, 6),
    new THREE.MeshStandardMaterial({ color: 0x3a2a1a, roughness: 0.9 })
  );
  grip.rotation.x = Math.PI / 2;
  grip.position.z = 0.1;
  group.add(grip);

  return group;
}

// ============================================================
// BOTTLE MESH (Drinking minigame)
// ============================================================
function createBottleMesh() {
  const group = new THREE.Group();

  // Large PET plastic body (semi-transparent amber)
  const bodyMat = new THREE.MeshStandardMaterial({
    color: 0xddcc66, roughness: 0.25, metalness: 0.05,
    transparent: true, opacity: 0.7
  });

  // PET bottle shape via LatheGeometry (rounder, bulbous profile)
  const pts = [
    new THREE.Vector2(0, 0),        // bottom center
    new THREE.Vector2(0.04, 0.01),  // bottom edge
    new THREE.Vector2(0.048, 0.06), // lower bulge
    new THREE.Vector2(0.05, 0.16),  // widest point
    new THREE.Vector2(0.048, 0.26), // upper bulge
    new THREE.Vector2(0.035, 0.30), // shoulder
    new THREE.Vector2(0.018, 0.34), // neck base
    new THREE.Vector2(0.016, 0.38), // neck top
    new THREE.Vector2(0, 0.38),     // top center
  ];
  const bodyGeo = new THREE.LatheGeometry(pts, 12);
  bodyMat.side = THREE.DoubleSide;
  const body = new THREE.Mesh(bodyGeo, bodyMat);
  group.add(body);

  // Green screw cap
  const cap = new THREE.Mesh(
    new THREE.CylinderGeometry(0.019, 0.019, 0.025, 8),
    new THREE.MeshStandardMaterial({ color: 0x2a8a2a, roughness: 0.7, metalness: 0.0 })
  );
  cap.position.y = 0.395;
  group.add(cap);

  // Green label band (prominent, apple theme)
  const labelMat = new THREE.MeshStandardMaterial({ color: 0x3a7a2a, roughness: 0.8 });
  const label = new THREE.Mesh(
    new THREE.CylinderGeometry(0.052, 0.052, 0.14, 10),
    labelMat
  );
  label.position.y = 0.16;
  group.add(label);

  // Thin accent stripe above label
  const stripe = new THREE.Mesh(
    new THREE.CylinderGeometry(0.051, 0.051, 0.015, 10),
    new THREE.MeshStandardMaterial({ color: 0x5aaa4a, roughness: 0.8 })
  );
  stripe.position.y = 0.245;
  group.add(stripe);

  // Inner wine level mesh (golden amber liquid)
  const wineLevelMat = new THREE.MeshStandardMaterial({
    color: 0xcc8800, roughness: 0.3, transparent: true, opacity: 0.7
  });
  const wineLevel = new THREE.Mesh(
    new THREE.CylinderGeometry(0.042, 0.045, 0.28, 8),
    wineLevelMat
  );
  wineLevel.position.y = 0.14;
  wineLevel.name = 'wineLevel';
  group.add(wineLevel);

  return group;
}

// ============================================================
// BEER CAN MESH
// ============================================================
function createBeerCanMesh() {
  const group = new THREE.Group();

  // Can body ‚Äî blue cylinder
  const bodyMat = new THREE.MeshStandardMaterial({ color: 0x2255aa, roughness: 0.4, metalness: 0.6 });
  const body = new THREE.Mesh(
    new THREE.CylinderGeometry(0.03, 0.03, 0.12, 12),
    bodyMat
  );
  body.position.y = 0.06;
  group.add(body);

  // Silver top rim
  const rimMat = new THREE.MeshStandardMaterial({ color: 0xcccccc, roughness: 0.3, metalness: 0.8 });
  const topRim = new THREE.Mesh(
    new THREE.CylinderGeometry(0.031, 0.031, 0.008, 12),
    rimMat
  );
  topRim.position.y = 0.124;
  group.add(topRim);

  // Silver bottom rim
  const bottomRim = new THREE.Mesh(
    new THREE.CylinderGeometry(0.031, 0.031, 0.008, 12),
    rimMat
  );
  bottomRim.position.y = 0.004;
  group.add(bottomRim);

  // Pull tab on top
  const tabMat = new THREE.MeshStandardMaterial({ color: 0xaaaaaa, roughness: 0.3, metalness: 0.7 });
  const tab = new THREE.Mesh(
    new THREE.BoxGeometry(0.012, 0.002, 0.02),
    tabMat
  );
  tab.position.set(0, 0.13, 0);
  group.add(tab);

  // Label stripe (lighter blue band)
  const labelMat = new THREE.MeshStandardMaterial({ color: 0x4488cc, roughness: 0.5, metalness: 0.5 });
  const label = new THREE.Mesh(
    new THREE.CylinderGeometry(0.0305, 0.0305, 0.04, 12),
    labelMat
  );
  label.position.y = 0.06;
  group.add(label);

  // Inner beer level mesh (golden liquid)
  const beerLevelMat = new THREE.MeshStandardMaterial({
    color: 0xddaa22, roughness: 0.3, transparent: true, opacity: 0.7
  });
  const beerLevel = new THREE.Mesh(
    new THREE.CylinderGeometry(0.026, 0.026, 0.10, 8),
    beerLevelMat
  );
  beerLevel.position.y = 0.055;
  beerLevel.name = 'beerLevel';
  group.add(beerLevel);

  return group;
}

// ============================================================
// DICE MESHES
// ============================================================
function createDieMesh() {
  const group = new THREE.Group();

  // White cube
  const cubeMat = new THREE.MeshStandardMaterial({ color: 0xf5f5f0, roughness: 0.6 });
  const cube = new THREE.Mesh(
    new THREE.BoxGeometry(0.08, 0.08, 0.08),
    cubeMat
  );
  group.add(cube);

  // Add dots as small dark spheres on faces
  const dotMat = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.8 });
  const dotGeo = new THREE.SphereGeometry(0.006, 6, 6);
  const r = 0.041; // just outside face
  const s = 0.02;  // dot spacing from center on face

  // Face patterns: [faceNormal, dotPositions]
  // We'll add all 6 faces with standard die layout (opposite faces sum to 7)
  const faces = [
    // 1 (front +Z): center
    { normal: [0,0,r], up: [0,1,0], right: [1,0,0], dots: [[0,0]] },
    // 6 (back -Z): 2x3 grid
    { normal: [0,0,-r], up: [0,1,0], right: [-1,0,0], dots: [[-s,s],[0,s],[s,s],[-s,-s],[0,-s],[s,-s]] },
    // 2 (right +X): diagonal
    { normal: [r,0,0], up: [0,1,0], right: [0,0,-1], dots: [[-s,s],[s,-s]] },
    // 5 (left -X): X pattern
    { normal: [-r,0,0], up: [0,1,0], right: [0,0,1], dots: [[-s,s],[s,s],[0,0],[-s,-s],[s,-s]] },
    // 3 (top +Y): diagonal + center
    { normal: [0,r,0], up: [0,0,-1], right: [1,0,0], dots: [[-s,s],[0,0],[s,-s]] },
    // 4 (bottom -Y): corners
    { normal: [0,-r,0], up: [0,0,1], right: [1,0,0], dots: [[-s,s],[s,s],[-s,-s],[s,-s]] },
  ];

  faces.forEach(f => {
    const n = new THREE.Vector3(...f.normal);
    const up = new THREE.Vector3(...f.up);
    const right = new THREE.Vector3(...f.right);
    f.dots.forEach(([u, v]) => {
      const dot = new THREE.Mesh(dotGeo, dotMat);
      dot.position.copy(n).add(right.clone().multiplyScalar(u)).add(up.clone().multiplyScalar(v));
      group.add(dot);
    });
  });

  return group;
}

function createDiceInHandMesh() {
  const group = new THREE.Group();
  const die1 = createDieMesh();
  die1.position.set(-0.03, 0, 0);
  die1.rotation.set(0.3, 0.2, 0.1);
  group.add(die1);
  const die2 = createDieMesh();
  die2.position.set(0.03, 0, 0);
  die2.rotation.set(-0.2, 0.4, -0.1);
  group.add(die2);
  return group;
}

// ============================================================
// JAVELIN (THROWN)
// ============================================================
let javelinTemplate = null;

function createJavelinTemplate() {
  javelinTemplate = createJavelinMesh();
  javelinTemplate.scale.set(1, 1, 1);
}

function spawnJavelin(pos, vel) {
  if (javelin) scene.remove(javelin);
  javelin = javelinTemplate.clone();
  javelin.position.copy(pos);
  javelinVel.copy(vel);
  scene.add(javelin);
  javelinFlying = true;
  javelinLanded = false;
  javelinHitTree = false;
}

// ============================================================
// PLAYER BODY MODEL (3rd person)
// ============================================================
function createPlayerBody() {
  playerBodyModel = createHumanoid(playerJacketColor, undefined, {
    beanieColor: playerBeanieColor,
    stripeColor: 0xdddddd
  });

  // Attach a javelin mesh to the right hand
  const jav = createJavelinMesh();
  jav.scale.set(0.9, 0.9, 0.9);
  jav.rotation.set(0, 0, Math.PI / 2);
  jav.position.set(0, 0.7, -0.15);
  jav.name = 'bodyJavelin';
  const armR = playerBodyModel.userData.armR;
  if (armR) armR.add(jav);

  playerBodyModel.visible = false;
  scene.add(playerBodyModel);
}

function updatePlayerBodyColors() {
  if (!playerBodyModel) return;
  const color = isNaked ? 0xd4a574 : playerJacketColor;
  // The body mesh (y~1.1) and arm meshes share the same bodyMat created in createHumanoid.
  // Find the body cylinder and update its material color ‚Äî this propagates to arms too.
  const children = playerBodyModel.children;
  for (const child of children) {
    if (child.isMesh && child.geometry) {
      // Body at y=1.1, arms at y=1.1 ‚Äî all share bodyMat
      if (child.position.y > 0.9 && child.position.y < 1.2) {
        child.material.color.setHex(color);
        break; // bodyMat is shared, one update is enough
      }
    }
  }
}

// ============================================================
// FOUL LINE CHALK MARKER
// ============================================================
function createFoulLineMarker() {
  const chalkMat = new THREE.MeshStandardMaterial({
    color: 0xeeeeee,
    roughness: 0.95,
    transparent: true,
    opacity: 0.6
  });

  // Chalk line on ground at Z = FOUL_LINE_Z
  const lineGeo = new THREE.PlaneGeometry(5, 0.08);
  const chalkLine = new THREE.Mesh(lineGeo, chalkMat);
  const ty = getTerrainHeight(0, FOUL_LINE_Z);
  chalkLine.position.set(0, ty + 0.02, FOUL_LINE_Z);
  chalkLine.rotation.x = -Math.PI / 2;
  scene.add(chalkLine);

  // Small dashes to make it look hand-drawn
  for (let i = 0; i < 6; i++) {
    const dx = -2.2 + i * 0.9;
    const dashGeo = new THREE.PlaneGeometry(0.3, 0.04);
    const dash = new THREE.Mesh(dashGeo, chalkMat);
    const dy = getTerrainHeight(dx, FOUL_LINE_Z - 0.15);
    dash.position.set(dx, dy + 0.02, FOUL_LINE_Z - 0.15);
    dash.rotation.x = -Math.PI / 2;
    dash.rotation.z = (Math.random() - 0.5) * 0.2;
    scene.add(dash);
  }
}

// ============================================================
// RUN-UP MECHANICS
// ============================================================
function updateRunUp(dt) {
  if (gameState !== STATES.RUN_UP && gameState !== STATES.CHARGING) return;

  // Exponential acceleration: starts slow, gets much faster near foul line
  // runUpSpeed is raw 0‚Äì1 input level; actual movement uses exponential curve
  if (isRunning) {
    runUpSpeed = Math.min(1.0, runUpSpeed + 0.7 * dt);
  } else {
    runUpSpeed = Math.max(0, runUpSpeed - 0.5 * dt);
  }

  // Exponential movement: speed¬≤ gives slow start, fast finish
  const moveSpeed = runUpSpeed * runUpSpeed * 12;
  playerRunZ -= moveSpeed * dt;

  // Foul line check
  if (playerRunZ < FOUL_LINE_Z) {
    triggerFoulLineViolation();
    return;
  }

  // Update body model position
  if (playerBodyModel) {
    const groundY = getTerrainHeight(0, playerRunZ);
    playerBodyModel.position.set(0, groundY, playerRunZ);
    playerBodyModel.rotation.y = Math.PI; // face forward (-Z)
  }

  // Update speed meter (show exponential feel)
  document.getElementById('speed-fill').style.height = (runUpSpeed * runUpSpeed * 100) + '%';
}

function updatePlayerBodyAnimation(dt, time) {
  if (!playerBodyModel || !playerBodyModel.visible) return;

  const legL = playerBodyModel.userData.legL;
  const legR = playerBodyModel.userData.legR;
  const armL = playerBodyModel.userData.armL;
  const armR = playerBodyModel.userData.armR;

  if (gameState === STATES.RUN_UP) {
    // Running animation ‚Äî use exponential speed for visual feel
    const speed = runUpSpeed * runUpSpeed;
    const freq = 6 + speed * 10; // faster legs at higher speed
    const amp = 0.2 + speed * 0.7;

    // Legs swing
    if (legL) legL.rotation.x = Math.sin(time * freq) * amp;
    if (legR) legR.rotation.x = -Math.sin(time * freq) * amp;

    // Left arm pumps (right arm holds javelin back)
    if (armL) {
      armL.rotation.x = -Math.sin(time * freq) * amp * 0.6;
      armL.rotation.z = 0.15;
    }
    if (armR) {
      // Hold javelin back during run
      armR.rotation.x = -0.8 - speed * 0.4;
      armR.rotation.z = -0.3;
    }

    // Body bob
    const bobAmt = speed * 0.06;
    const groundY = getTerrainHeight(0, playerRunZ);
    playerBodyModel.position.y = groundY + Math.abs(Math.sin(time * freq)) * bobAmt;

  } else if (gameState === STATES.CHARGING) {
    if (isRunning) {
      // Running while charging ‚Äî keep legs moving, only change arms to windup
      const speed = runUpSpeed * runUpSpeed;
      const freq = 6 + speed * 10;
      const amp = 0.2 + speed * 0.7;
      if (legL) legL.rotation.x = Math.sin(time * freq) * amp;
      if (legR) legR.rotation.x = -Math.sin(time * freq) * amp;
      const bobAmt = speed * 0.06;
      const groundY = getTerrainHeight(0, playerRunZ);
      playerBodyModel.position.y = groundY + Math.abs(Math.sin(time * freq)) * bobAmt;
    } else {
      // Standing throw ‚Äî planted legs
      if (legL) legL.rotation.x = 0.2;
      if (legR) legR.rotation.x = -0.3;
    }
    if (armL) {
      armL.rotation.x = 0.3;
      armL.rotation.z = 0.3;
    }
    if (armR) {
      // Pull back further as charge increases
      armR.rotation.x = -1.2 - chargePower * 0.6;
      armR.rotation.z = -0.3;
    }

  } else if (gameState === STATES.THROW_RELEASE) {
    // Throw animation: arm whips forward
    const t = Math.min(throwReleaseTimer / 0.5, 1);
    if (armR) {
      armR.rotation.x = -1.8 + t * 3.0; // from far back to far forward
      armR.rotation.z = -0.3 + t * 0.2;
    }
    if (armL) {
      armL.rotation.x = 0.3 - t * 0.5;
      armL.rotation.z = 0.3 + t * 0.3;
    }
    // Lunge forward
    if (legL) legL.rotation.x = 0.2 + t * 0.4;
    if (legR) legR.rotation.x = -0.3 - t * 0.3;

    // Hide javelin from hand at release point (t=0.6 of animation = 0.3s)
    if (t > 0.6) {
      const bodyJav = armR ? armR.getObjectByName('bodyJavelin') : null;
      if (bodyJav) bodyJav.visible = false;
    }
  }
}

function triggerFoulLineViolation() {
  landedFoul = true;
  javelinFlying = false;
  javelinLanded = true;
  javelinHitTree = false;
  landedDistance = 0;

  // Hide run-up UI
  document.getElementById('speed-meter').style.display = 'none';
  document.getElementById('speed-label').style.display = 'none';
  document.getElementById('run-instruction').style.display = 'none';

  // Hide body model
  if (playerBodyModel) playerBodyModel.visible = false;
  if (armGroup) armGroup.visible = false;

  playSound('impact');

  // Go through LANDED ‚Üí RESULT using existing flow
  gameState = STATES.LANDED;

  // Brief delay, then show foul line result using existing showLandedResult
  // Override the foul text after it runs
  setTimeout(() => {
    showLandedResult();
    // Override the foul text to specify foul line
    const distEl = document.getElementById('distance-display');
    distEl.innerHTML = 'FOUL!<span class="sub">Crossed the foul line!</span>';
    showDialogue('Coach Matti', 'You crossed the line! That\'s a foul, friend.');
  }, 400);
}

// ============================================================
// DIALOGUE SYSTEM
// ============================================================
function showDialogue(name, text, callback) {
  dialogueQueue.push({ name, text, callback });
  if (!dialogueActive) advanceDialogue();
}

function advanceDialogue() {
  if (dialogueQueue.length === 0) {
    dialogueActive = false;
    document.getElementById('dialogue-box').style.display = 'none';
    if (dialogueCallback) {
      const cb = dialogueCallback;
      dialogueCallback = null;
      cb();
      // Callback may have pushed new dialogues
      if (dialogueQueue.length > 0 && !dialogueActive) {
        advanceDialogue();
      }
    }
    return;
  }

  dialogueActive = true;
  const d = dialogueQueue.shift();
  dialogueFullText = d.text;
  dialogueCharIndex = 0;
  dialogueTimer = 0;
  dialogueCallback = d.callback || null;

  document.getElementById('dialogue-box').style.display = 'block';
  document.getElementById('dialogue-name').textContent = d.name;
  document.getElementById('dialogue-text').textContent = '';
}

function updateDialogue(dt) {
  if (!dialogueActive) return;
  dialogueTimer += dt;
  if (dialogueCharIndex < dialogueFullText.length) {
    const charsPerSec = 40;
    const target = Math.min(Math.floor(dialogueTimer * charsPerSec), dialogueFullText.length);
    if (target > dialogueCharIndex) {
      dialogueCharIndex = target;
      document.getElementById('dialogue-text').textContent = dialogueFullText.substring(0, dialogueCharIndex);
    }
  }
}

function skipOrAdvanceDialogue() {
  if (!dialogueActive) return;
  if (dialogueCharIndex < dialogueFullText.length) {
    // Show full text
    dialogueCharIndex = dialogueFullText.length;
    document.getElementById('dialogue-text').textContent = dialogueFullText;
  } else {
    advanceDialogue();
  }
}

// ============================================================
// GAME FLOW - DIALOGUES
// ============================================================
function getIntroDialogue() {
  return [
    { name: 'Coach Matti', text: `Terve! Welcome to the forest javelin, ${playerName}. This is where legends are made... or at least where sticks are thrown.` },
    { name: 'Coach Matti', text: 'The rules are simple: throw the stick as far as you can between those two big pines. One throw per round ‚Äî make it count!' },
    { name: 'Coach Matti', text: 'Watch out for the birch tree in the middle - hit that and your throw is foul! The crowd will have a good laugh though.' },
    { name: 'Coach Matti', text: 'Aim with the mouse. Hold Space to charge power, release to throw. Feel the wind and read the forest. Good luck!' },
  ];
}

function getRoundIntroDialogue(round) {
  const dialogues = [
    [
      { name: 'Coach Matti', text: `Round 1: "${ROUNDS[0].name}". Just a friendly warm-up. Try to throw past ${ROUNDS[0].target} meters.` },
      { name: 'Jukka', text: `Hey ${playerName}! Show us what you got. No pressure... mostly.` },
    ],
    [
      { name: 'Coach Matti', text: `Round 2: "${ROUNDS[1].name}". The locals are watching now. You need ${ROUNDS[1].target} meters to advance.` },
      { name: 'Heikki', text: "I've been throwing sticks in this forest since I was five. Good luck keeping up." },
      { name: 'Coach Matti', text: 'Watch the wind carefully this round. Angle your throw to work with it, not against it.' },
    ],
    [
      { name: 'Coach Matti', text: `Round 3: "${ROUNDS[2].name}". The wind is really picking up now. ${ROUNDS[2].target} meters to survive.` },
      { name: 'Jukka', text: 'Feel that wind? Even the trees are nervous.' },
      { name: 'Coach Matti', text: 'Use the wind to your advantage. Sometimes a crosswind can carry the stick further than you think.' },
    ],
    [
      { name: 'Coach Matti', text: `Round 4: "${ROUNDS[3].name}". Only the truly determined make it past this point. ${ROUNDS[3].target} meters.` },
      { name: 'Heikki', text: 'Most people quit by now. The forest respects stubbornness though.' },
      { name: 'Jukka', text: `Come on ${playerName}, show the forest who is boss!` },
    ],
    [
      { name: 'Coach Matti', text: `Round 5: "${ROUNDS[4].name}". ${ROUNDS[4].target} meters. This is where champions are separated from everyone else.` },
      { name: 'Coach Matti', text: 'Strong winds and that birch is right in your way. You can try to throw over it or angle around it.' },
      { name: 'Heikki', text: 'Nobody beats the forest. Especially not with this wind.' },
    ],
    [
      { name: 'Coach Matti', text: `Round 6: "${ROUNDS[5].name}". The final round. ${ROUNDS[5].target} meters for the championship.` },
      { name: 'Coach Matti', text: 'But first... there is one last tradition. The final throw must be made... without clothing.' },
      { name: 'Jukka', text: 'WHAT?! You cannot be serious, Matti!' },
      { name: 'Heikki', text: 'He is serious. The old champions always threw the last one naked. It is about becoming one with the forest.' },
      { name: 'Coach Matti', text: `Strip down, ${playerName}. Nothing left to lose ‚Äî literally. Let the forest see the real you.` },
    ],
  ];
  return dialogues[round] || [];
}

function getTreeHitDialogue() {
  const lines = [
    { name: 'Coach Matti', text: 'THWACK! Right in the birch! That poor tree...' },
    { name: 'Jukka', text: 'Ha! The tree wins this round!' },
    { name: 'Coach Matti', text: "It's a foul throw. The tree has been standing there for 80 years - try throwing AROUND it." },
  ];
  return lines[Math.floor(Math.random() * lines.length)];
}

function getGoodThrowDialogue(dist) {
  if (dist > 50) return { name: 'Coach Matti', text: `About ${Math.round(dist)} meters! That stick really flew! The forest hasn't seen a throw like that in years.` };
  if (dist > 35) return { name: 'Jukka', text: `About ${Math.round(dist)} meters - not bad at all! You might actually be good at this.` };
  return { name: 'Coach Matti', text: `About ${Math.round(dist)} meters. Decent throw. You can do better though!` };
}

function getVictoryDialogue() {
  return [
    { name: 'Coach Matti', text: 'INCREDIBLE! You did it! The new Forest Javelin Champion!' },
    { name: 'Jukka', text: `I... cannot believe it. ${playerName} actually did it naked and everything!` },
    { name: 'Heikki', text: "Fair play. That was the finest stick-throwing I've ever witnessed. Clothed or otherwise." },
    { name: 'Coach Matti', text: `Now please put your clothes back on, ${playerName}. The mosquitoes are getting interested.` },
    { name: 'Coach Matti', text: "The legend of the forest javelin lives on. Until next autumn, champion!" },
  ];
}

function getDefeatDialogue() {
  return [
    { name: 'Coach Matti', text: `Not quite far enough... You needed ${ROUNDS[currentRound].target} meters.` },
    { name: 'Coach Matti', text: "Don't worry. The forest is patient. Come back when the leaves fall again." },
  ];
}

// ============================================================
// DRINKING MINIGAME DIALOGUES
// ============================================================
function getDrinkingIntroDialogue() {
  return [
    { name: 'Coach Matti', text: 'Wait ‚Äî before you throw, there is a tradition. Every competitor must first drink an entire bottle of Helmeilev√§ Omenaviini.' },
    { name: 'Coach Matti', text: "It's apple wine. Strong stuff. The old champions swore it gave them power. Personally I think it just made them brave." },
    { name: 'Jukka', text: `Ha! Let's see if ${playerName} can even handle a whole bottle. My grandmother drinks faster than most people here.` },
    { name: 'Heikki', text: 'A word of advice ‚Äî pace yourself. Drink too fast and your stomach will revolt. Nobody wants to see that.' },
    { name: 'Coach Matti', text: 'Hold Space to drink. But take breaks or the nausea will get you. Finish the whole bottle to proceed!' },
  ];
}

function getDrinkingCompleteDialogue() {
  return [
    { name: 'Coach Matti', text: 'Ha! You finished the whole bottle! The forest spirits smile upon you... or maybe that is just the wine.' },
    { name: 'Jukka', text: 'Not bad... but can you still throw straight? That stuff hits harder than it tastes.' },
    { name: 'Coach Matti', text: 'Your hands might wobble a bit now. That is part of the challenge. The true champion throws well even after the wine!' },
  ];
}

function getPukeDialogue() {
  return [
    { name: 'Coach Matti', text: 'Oh no... I told you to pace yourself! The apple wine demands respect!' },
    { name: 'Jukka', text: `BAHAHAHA! ${playerName} could not handle it! Someone get a mop!` },
    { name: 'Heikki', text: 'The forest takes as much as it gives. There is wisdom in knowing your limits... and you just found yours.' },
  ];
}

function getBottle2IntroDialogue() {
  return [
    { name: 'Coach Matti', text: `Now ${playerName}, there is one more tradition. The second bottle ‚Äî 15% strong batch. Real champion stuff.` },
    { name: 'Jukka', text: 'Drinking between throws! Now this is what the championship is really about.' },
    { name: 'Coach Matti', text: 'This one hits harder. Pace yourself or your next throw will go straight into the trees.' },
  ];
}

function getBottle2CompleteDialogue() {
  return [
    { name: 'Coach Matti', text: `Both bottles down! ${playerName} has earned the right to continue!` },
    { name: 'Heikki', text: 'Look at that wobble... this should be interesting.' },
  ];
}

function getBottle2GameOverDialogue() {
  return [
    { name: 'Coach Matti', text: `Sorry ${playerName}, you cannot continue past round 3 without drinking both bottles. Those are the rules.` },
    { name: 'Heikki', text: 'The tradition must be respected. No bottle, no championship.' },
  ];
}

// ============================================================
// WIND
// ============================================================
function randomizeWind() {
  const round = ROUNDS[currentRound];
  windSpeed = round.windBase * (0.5 + Math.random() * 0.8);
  windAngle = Math.random() * Math.PI * 2;
}

function getWindDisplay() {
  const dirs = ['N', 'NE', 'E', 'SE', 'S', 'SW', 'W', 'NW'];
  const idx = Math.round(((windAngle + Math.PI) / (Math.PI * 2)) * 8) % 8;
  const arrow = ['‚Üì', '‚Üô', '‚Üê', '‚Üñ', '‚Üë', '‚Üó', '‚Üí', '‚Üò'][idx];
  return `Wind: ${windSpeed.toFixed(1)} m/s ${dirs[idx]} ${arrow}`;
}

// ============================================================
// JAVELIN PHYSICS
// ============================================================
function updateJavelinPhysics(dt) {
  if (!javelinFlying || !javelin) return;

  const gravity = new THREE.Vector3(0, -9.81, 0);

  // Wind force
  const windForce = new THREE.Vector3(
    Math.cos(windAngle) * windSpeed * 0.15,
    0,
    Math.sin(windAngle) * windSpeed * 0.15
  );

  // Drag (higher than real javelin - it's a stick)
  const speed = javelinVel.length();
  const dragCoeff = 0.004;
  const drag = javelinVel.clone().normalize().multiplyScalar(-dragCoeff * speed * speed);

  // Slight lift if nose is angled up
  const velDir = javelinVel.clone().normalize();
  const lift = new THREE.Vector3(0, Math.max(0, -velDir.y) * speed * 0.03, 0);

  // Apply forces
  const accel = gravity.clone().add(windForce).add(drag).add(lift);
  javelinVel.add(accel.multiplyScalar(dt));

  javelin.position.add(javelinVel.clone().multiplyScalar(dt));

  // Align javelin to velocity (pitching moment)
  const targetDir = javelinVel.clone().normalize();
  const currentForward = new THREE.Vector3(0, 0, -1);
  const quat = new THREE.Quaternion().setFromUnitVectors(currentForward, targetDir);
  javelin.quaternion.slerp(quat, 0.05);

  // Check collision with obstacle pine
  if (obstaclePine) {
    const dx = javelin.position.x - obstaclePine.position.x;
    const dz = javelin.position.z - obstaclePine.position.z;
    const dist = Math.sqrt(dx * dx + dz * dz);
    const obstBaseY = obstaclePine.position.y;
    if (dist < obstaclePine.userData.radius &&
        javelin.position.y > obstBaseY && javelin.position.y < obstBaseY + 14) {
      // Hit the tree!
      javelinFlying = false;
      javelinHitTree = true;
      javelinVel.set(dx * 3, 2, dz * 3); // bounce off
      playSound('tree_hit');
      playSound('laugh');

      setTimeout(() => {
        onJavelinLanded(true);
      }, 500);
      return;
    }
  }

  // Check if out of sector (between the two sector pines)
  const sectorLeft = sectorLeftPine.position.x;
  const sectorRight = sectorRightPine.position.x;

  // Ground collision
  const terrainY = getTerrainHeight(javelin.position.x, javelin.position.z);
  if (javelin.position.y <= terrainY + 0.1) {
    javelinFlying = false;
    javelinLanded = true;

    // Check if tip first (valid) or tumble (foul)
    const tipDown = velDir.y < -0.3;

    // Check if in sector
    const inSector = javelin.position.x > sectorLeft &&
                     javelin.position.x < sectorRight;

    let foul = !tipDown || !inSector;
    let drunkFoul = false;

    // Drunk randomizer: wine impairs throw accuracy
    // After bottle 1 (always true once throwing starts): 69% lawful
    // After bottle 2: only 31% lawful
    if (!foul) {
      const lawfulChance = bottle2Completed ? 0.31 : 0.69;
      if (Math.random() > lawfulChance) {
        foul = true;
        drunkFoul = true;
      }
    }

    javelin.position.y = terrainY + 0.1;

    if (tipDown && !drunkFoul) {
      // Stick it in the ground at an angle
      javelin.rotation.x = -Math.PI / 4;
    }

    playSound('impact');
    if (!foul) playSound('cheer');

    onJavelinLanded(foul, drunkFoul);
  }
}

function onJavelinLanded(foul, drunkFoul = false) {
  javelinFlying = false;
  landedFoul = foul;
  landedDrunkFoul = drunkFoul;

  if (!foul) {
    // Calculate distance from foul line
    const dx = javelin.position.x;
    const dz = javelin.position.z - FOUL_LINE_Z;
    landedDistance = Math.sqrt(dx * dx + dz * dz);

    // Fuzzy display (no official markers)
    const displayDist = Math.round(landedDistance) + (Math.random() > 0.5 ? 0.5 : 0);

    if (landedDistance > bestDistances[currentRound]) {
      bestDistances[currentRound] = landedDistance;
    }
  } else {
    landedDistance = 0;
  }

  gameState = STATES.LANDED;

  // Show distance after brief delay
  setTimeout(() => {
    showLandedResult();
  }, 800);
}

function showLandedResult() {
  gameState = STATES.RESULT;

  const distEl = document.getElementById('distance-display');

  if (landedFoul) {
    if (javelinHitTree) {
      distEl.innerHTML = 'FOUL!<span class="sub">Hit the obstacle tree!</span>';
      // Show tree hit dialogue
      const d = getTreeHitDialogue();
      showDialogue(d.name, d.text, null);
    } else if (landedDrunkFoul) {
      const msgs = [
        'The wine got the better of you on that one.',
        'Your aim wandered ‚Äî too much Omenaviini!',
        'The forest is spinning... so is your javelin.',
        'That throw had more wobble than technique.',
        'Helmeilev√§ Omenaviini strikes again!',
      ];
      const msg = msgs[Math.floor(Math.random() * msgs.length)];
      distEl.innerHTML = 'FOUL!<span class="sub">Drunken throw!</span>';
      showDialogue('Coach Matti', msg, null);
    } else {
      distEl.innerHTML = 'FOUL!<span class="sub">Outside the sector or bad landing</span>';
    }
  } else {
    const approx = `~${Math.round(landedDistance)}m`;
    distEl.innerHTML = `${approx}`;
    // Show reaction dialogue
    const d = getGoodThrowDialogue(landedDistance);
    showDialogue(d.name, d.text, null);
  }

  distEl.style.display = 'block';

  // NPC reactions
  npcMeshes.forEach(npc => {
    npc.userData.reaction = landedFoul ? 'headshake' : (landedDistance > 40 ? 'celebrate' : 'clap');
    npc.userData.reactionTimer = 2.0;
  });

  // Auto-advance after delay
  setTimeout(() => {
    distEl.style.display = 'none';
    if (landedFoul) {
      // Foul = 0m, no retry, advance to next round
      currentRound++;

      if (currentRound === 1) {
        bottle2Available = true;
        beerAvailable = true;
        diceAvailable = true;
      }
      if (currentRound === 3 && !bottle2Completed) {
        gameState = STATES.BOTTLE2_GAMEOVER;
        const dialogue = getBottle2GameOverDialogue();
        dialogue.forEach((d, i) => {
          showDialogue(d.name, d.text, i === dialogue.length - 1 ? () => {
            showResultOverlay('DISQUALIFIED!', 'Must drink both bottles to continue past round 3. Click to restart.');
          } : null);
        });
        return;
      }
      if (currentRound >= 6) {
        restorePlayerClothing();
        gameState = STATES.VICTORY;
        const vd = getVictoryDialogue();
        vd.forEach((d, i) => {
          showDialogue(d.name, d.text, i === vd.length - 1 ? () => {
            showResultOverlay('CHAMPION!', 'You are the Forest Javelin Champion!');
          } : null);
        });
        return;
      }
      gameState = STATES.ROUND_DIALOGUE;
      const rd = getRoundIntroDialogue(currentRound);
      rd.forEach((d, i) => {
        showDialogue(d.name, d.text, i === rd.length - 1 ? () => {
          if (currentRound === 5) {
            undressPlayer();
          }
          randomizeWind();
          resetForThrow();
        } : null);
      });
    } else {
      endRound();
    }
  }, 3500);
}

function endRound() {
  const best = bestDistances[currentRound];
  const target = ROUNDS[currentRound].target;

  if (best >= target) {
    // Round passed!
    currentRound++;

    if (currentRound === 1) {
      bottle2Available = true;
      beerAvailable = true;
      diceAvailable = true;
    }
    if (currentRound === 3 && !bottle2Completed) {
      gameState = STATES.BOTTLE2_GAMEOVER;
      const dialogue = getBottle2GameOverDialogue();
      dialogue.forEach((d, i) => {
        showDialogue(d.name, d.text, i === dialogue.length - 1 ? () => {
          showResultOverlay('DISQUALIFIED!', 'Must drink both bottles to continue past round 3. Click to restart.');
        } : null);
      });
      return;
    }

    if (currentRound >= 6) {
      // Victory!
      restorePlayerClothing();
      gameState = STATES.VICTORY;
      const vd = getVictoryDialogue();
      vd.forEach((d, i) => {
        showDialogue(d.name, d.text, i === vd.length - 1 ? () => {
          showResultOverlay('CHAMPION!', 'You are the Forest Javelin Champion!');
        } : null);
      });
    } else {
      // Next round dialogue
      gameState = STATES.ROUND_DIALOGUE;
      const rd = getRoundIntroDialogue(currentRound);
      rd.forEach((d, i) => {
        showDialogue(d.name, d.text, i === rd.length - 1 ? () => {
          if (currentRound === 5) {
            undressPlayer();
          }
          randomizeWind();
          resetForThrow();
        } : null);
      });
    }
  } else {
    // Defeat
    gameState = STATES.DEFEAT;
    const dd = getDefeatDialogue();
    dd.forEach((d, i) => {
      showDialogue(d.name, d.text, i === dd.length - 1 ? () => {
        showResultOverlay('NOT ENOUGH', `Best: ~${Math.round(best)}m / Target: ${target}m. Click to retry round.`);
      } : null);
    });
  }
}

function showResultOverlay(title, sub) {
  document.getElementById('result-title').textContent = title;
  document.getElementById('result-sub').textContent = isMobile ? sub.replace(/Click/g, 'Tap') : sub;
  document.getElementById('result-overlay').style.display = 'flex';
}

// ============================================================
// DRINKING MINIGAME FLOW
// ============================================================
function startDrinkingMinigame() {
  gameState = STATES.DRINKING;
  drinkProgress = 0;
  nauseaLevel = 0;
  isDrinking = false;
  drinkGulpTimer = 0;
  lastStomachGurgle = 0;

  // Show UI
  document.getElementById('drink-meter').style.display = 'block';
  document.getElementById('drink-fill').style.height = '0%';
  document.getElementById('drink-label').style.display = 'block';
  document.getElementById('drink-label').textContent = 'BOTTLE';
  document.getElementById('nausea-meter').style.display = 'block';
  document.getElementById('nausea-fill').style.height = '0%';
  document.getElementById('nausea-label').style.display = 'block';
  document.getElementById('drink-instruction').style.display = 'block';
  document.getElementById('drink-instruction').textContent = isMobile ? 'Hold DRINK to drink ‚Äî but pace yourself!' : 'Hold SPACE to drink ‚Äî but pace yourself!';
  document.getElementById('crosshair').style.display = 'none';

  // Show bottle, hide javelin
  if (armGroup) {
    const stick = armGroup.getObjectByName('stickInHand');
    if (stick) stick.visible = false;
    const bottle = armGroup.getObjectByName('bottleInHand');
    if (bottle) bottle.visible = true;
  }

  bottleNumber = 1;
  armAnimState = 'drinking_idle';
  armAnimTime = 0;

  // Set camera to first person looking forward
  camera.position.copy(PLAYER_POS);
  camera.rotation.set(0, 0, 0);

  // Update info panel
  document.getElementById('info-panel').innerHTML = 'Pohjolan Omenapuisto<br>Apple Wine ‚Äî 12%';
  document.getElementById('wind-indicator').innerHTML = '';
}

function updateDrinking(dt, time) {
  if (gameState !== STATES.DRINKING) return;

  // Delegate to beer drinking if active
  if (isDrinkingBeer) {
    updateBeerDrinking(dt, time);
    return;
  }

  const drinkRate = bottleNumber === 2 ? BOTTLE2_DRINK_RATE : DRINK_RATE;
  const nauseaBuild = bottleNumber === 2 ? BOTTLE2_NAUSEA_BUILD_RATE : NAUSEA_BUILD_RATE;
  const nauseaDecay = bottleNumber === 2 ? BOTTLE2_NAUSEA_DECAY_RATE : NAUSEA_DECAY_RATE;
  const nauseaAccel = bottleNumber === 2 ? BOTTLE2_NAUSEA_ACCEL : DRINK_NAUSEA_ACCEL;

  if (isDrinking) {
    // Increase drink progress
    drinkProgress += drinkRate * dt;

    // Build nausea (quadratic feel: base + acceleration based on current nausea)
    nauseaLevel += (nauseaBuild + nauseaAccel * nauseaLevel) * dt;

    // Gulp sounds (~4 per second)
    drinkGulpTimer += dt;
    if (drinkGulpTimer >= 0.25) {
      drinkGulpTimer = 0;
      playSound('gulp');
    }
  } else {
    // Nausea decays while resting
    nauseaLevel = Math.max(0, nauseaLevel - nauseaDecay * dt);
    drinkGulpTimer = 0;
  }

  // Clamp values
  drinkProgress = Math.min(drinkProgress, 1);
  nauseaLevel = Math.min(nauseaLevel, 1);

  // Stomach gurgle at high nausea
  if (nauseaLevel > 0.7 && time - lastStomachGurgle > 1.5 + Math.random() * 2) {
    lastStomachGurgle = time;
    playSound('stomach_gurgle');
  }

  // Update wine level in bottle
  if (armGroup) {
    const bottle = armGroup.getObjectByName('bottleInHand');
    if (bottle) {
      const wineLevel = bottle.getObjectByName('wineLevel');
      if (wineLevel) {
        const remaining = 1 - drinkProgress;
        wineLevel.scale.y = Math.max(0.01, remaining);
        wineLevel.position.y = 0.125 * remaining;
      }
    }
  }

  // Update UI
  updateDrinkingUI();
  updateNauseaEffects(time);

  // Check puke (nausea maxed)
  if (nauseaLevel >= 1) {
    triggerPuke();
    return;
  }

  // Check complete (bottle emptied)
  if (drinkProgress >= 1) {
    completeDrinking();
    return;
  }
}

function updateDrinkingUI() {
  document.getElementById('drink-fill').style.height = (drinkProgress * 100) + '%';
  document.getElementById('nausea-fill').style.height = (nauseaLevel * 100) + '%';

  // Update info panel with status
  let status = '';
  if (nauseaLevel > 0.8) status = 'DANGER! Slow down!';
  else if (nauseaLevel > 0.6) status = 'Getting queasy...';
  else if (nauseaLevel > 0.4) status = 'Feeling warm...';
  else if (drinkProgress > 0.7) status = 'Almost there!';
  else if (drinkProgress > 0) status = 'Drinking...';
  else status = 'Ready to drink';

  document.getElementById('info-panel').innerHTML =
    `Pohjolan Omenapuisto<br>` +
    `Bottle: ${Math.round(drinkProgress * 100)}%<br>` +
    `${status}`;
}

function updateNauseaEffects(time) {
  const overlay = document.getElementById('nausea-overlay');

  if (nauseaLevel > 0.3) {
    overlay.style.display = 'block';
    const alpha = (nauseaLevel - 0.3) / 0.7; // 0‚Üí1 over nausea 0.3‚Üí1.0
    // Pulse the vignette at high nausea
    const pulse = nauseaLevel > 0.6 ? Math.sin(time * 4) * 0.1 : 0;
    const a = Math.min(0.6, alpha * 0.6 + pulse);
    overlay.style.background = `radial-gradient(ellipse at center,
      rgba(0,80,0,0) 30%,
      rgba(0,60,0,${a.toFixed(2)}) 100%)`;
  } else {
    overlay.style.display = 'none';
  }

  // Camera nausea wobble during drinking
  if (gameState === STATES.DRINKING && nauseaLevel > 0.2) {
    const wobble = (nauseaLevel - 0.2) * 0.05;
    camera.rotation.z = Math.sin(time * 3) * wobble;
    camera.rotation.x = Math.sin(time * 2.3) * wobble * 0.5;
  }
}

function completeDrinking() {
  if (bottleNumber === 2) {
    isDrinking = false;
    bottle2Completed = true;
    bottle2InProgress = false;
    wineWobbleIntensity = Math.min(0.18, 0.08 + nauseaLevel * 0.15);
    playSound('burp');
    hideDrinkingUI();
    document.getElementById('bottle-toggle').style.display = 'none';

    gameState = STATES.ROUND_DIALOGUE;
    const dialogue = getBottle2CompleteDialogue();
    dialogue.forEach((d, i) => {
      showDialogue(d.name, d.text, i === dialogue.length - 1 ? () => {
        // Restore aim state
        aimPitch = preBottle2AimPitch;
        aimYaw = preBottle2AimYaw;

        // Show javelin, hide other items
        currentItemIndex = 0;
        showHandItem('stickInHand');

        gameState = STATES.AIMING;
        document.getElementById('crosshair').style.display = '';
        document.getElementById('drink-label').style.display = 'none';
        armAnimState = 'idle';
        armAnimTime = 0;
        updateItemToggleButton();
      } : null);
    });
    return;
  }

  isDrinking = false;
  gameState = STATES.CELEBRATION_CAMERA;
  armAnimState = 'drinking_done';
  armAnimTime = 0;

  // Capture wobble intensity based on remaining nausea
  wineWobbleIntensity = 0.08 + nauseaLevel * 0.1;

  playSound('burp');
  hideDrinkingUI();

  // Start celebration camera
  celebrationAnimTime = 0;

  // Hide first-person arm during bird's eye
  if (armGroup) armGroup.visible = false;

  // NPC celebrate reactions
  npcMeshes.forEach(npc => {
    npc.userData.reaction = 'celebrate';
    npc.userData.reactionTimer = CELEBRATION_DURATION + 2;
  });
}

function onCelebrationComplete() {
  gameState = STATES.DRINKING_COMPLETE;

  // Restore first-person arm
  if (armGroup) armGroup.visible = true;

  // Snap camera back to first person
  camera.position.copy(PLAYER_POS);
  camera.rotation.set(0, 0, 0);

  // Show completion dialogue, then chain to round 1
  const dialogue = getDrinkingCompleteDialogue();
  dialogue.forEach((d, i) => {
    showDialogue(d.name, d.text, i === dialogue.length - 1 ? () => {
      // Hide bottle, show javelin
      if (armGroup) {
        const bottle = armGroup.getObjectByName('bottleInHand');
        if (bottle) bottle.visible = false;
        const stick = armGroup.getObjectByName('stickInHand');
        if (stick) stick.visible = true;
      }

      // Start NPC walk to spectating positions
      startNPCWalkToPositions();

      // Start round 1
      currentRound = 0;
      currentThrow = 0;
      gameState = STATES.ROUND_DIALOGUE;
      const rd = getRoundIntroDialogue(0);
      rd.forEach((rd2, j) => {
        showDialogue(rd2.name, rd2.text, j === rd.length - 1 ? () => {
          randomizeWind();
          resetForThrow();
        } : null);
      });
    } : null);
  });
}

function triggerPuke() {
  isDrinking = false;
  bottle2InProgress = false;
  gameState = STATES.PUKE_GAMEOVER;

  playSound('puke');
  playSound('laugh');
  hideDrinkingUI();

  // NPC reactions
  npcMeshes.forEach(npc => {
    npc.userData.reaction = 'celebrate'; // they find it hilarious
    npc.userData.reactionTimer = 4.0;
  });

  // Show puke dialogue then game over overlay
  const dialogue = getPukeDialogue();
  dialogue.forEach((d, i) => {
    showDialogue(d.name, d.text, i === dialogue.length - 1 ? () => {
      document.getElementById('puke-overlay').style.display = 'flex';
    } : null);
  });
}

function startRoundDrinking() {
  preBottle2AimPitch = aimPitch;
  preBottle2AimYaw = aimYaw;
  bottleNumber = 2;

  if (bottle2InProgress) {
    startDrinkingMinigameBottle2();
    return;
  }

  gameState = STATES.ROUND_DIALOGUE;
  const dialogue = getBottle2IntroDialogue();
  dialogue.forEach((d, i) => {
    showDialogue(d.name, d.text, i === dialogue.length - 1 ? () => {
      startDrinkingMinigameBottle2();
    } : null);
  });
}

function startDrinkingMinigameBottle2() {
  gameState = STATES.DRINKING;
  if (!bottle2InProgress) {
    drinkProgress = 0;
    nauseaLevel = 0;
  }
  bottle2InProgress = true;
  isDrinking = false;
  drinkGulpTimer = 0;
  lastStomachGurgle = 0;

  // Show UI
  document.getElementById('drink-meter').style.display = 'block';
  document.getElementById('drink-fill').style.height = (drinkProgress * 100) + '%';
  document.getElementById('drink-label').style.display = 'block';
  document.getElementById('drink-label').textContent = 'BOTTLE 2';
  document.getElementById('nausea-meter').style.display = 'block';
  document.getElementById('nausea-fill').style.height = (nauseaLevel * 100) + '%';
  document.getElementById('nausea-label').style.display = 'block';
  document.getElementById('drink-instruction').style.display = 'block';
  document.getElementById('drink-instruction').textContent = isMobile ? 'Hold DRINK to drink ‚Äî this one is STRONGER!' : 'Hold SPACE to drink ‚Äî this one is STRONGER!';
  document.getElementById('crosshair').style.display = 'none';

  // Keep toggle visible, update for cycling
  currentItemIndex = 3; // wine selected
  updateItemToggleButton();

  // Show bottle, hide other items
  if (armGroup) {
    armGroup.visible = true;
    showHandItem('bottleInHand');
    const bottle = armGroup.getObjectByName('bottleInHand');

    // Restore wine level from current progress
    const wineLevel = bottle ? bottle.getObjectByName('wineLevel') : null;
    if (wineLevel) {
      const remaining = 1 - drinkProgress;
      wineLevel.scale.y = Math.max(0.01, remaining);
      wineLevel.position.y = 0.125 * remaining;
    }
  }

  armAnimState = 'drinking_idle';
  armAnimTime = 0;

  // Set camera to first person looking forward
  camera.position.copy(PLAYER_POS);
  camera.rotation.set(0, 0, 0);

  // Update info panel
  document.getElementById('info-panel').innerHTML = 'Pohjolan Omenapuisto<br>Apple Wine ‚Äî 15% (Strong Batch!)';
  document.getElementById('wind-indicator').innerHTML = '';
}

function hideDrinkingUI() {
  document.getElementById('drink-meter').style.display = 'none';
  document.getElementById('drink-label').style.display = 'none';
  document.getElementById('nausea-meter').style.display = 'none';
  document.getElementById('nausea-label').style.display = 'none';
  document.getElementById('drink-instruction').style.display = 'none';
  document.getElementById('nausea-overlay').style.display = 'none';
}

// ============================================================
// ITEM CYCLING
// ============================================================
function hideAllHandItems() {
  if (!armGroup) return;
  const stick = armGroup.getObjectByName('stickInHand');
  const bottle = armGroup.getObjectByName('bottleInHand');
  const beer = armGroup.getObjectByName('beerCanInHand');
  const dice = armGroup.getObjectByName('diceInHand');
  if (stick) stick.visible = false;
  if (bottle) bottle.visible = false;
  if (beer) beer.visible = false;
  if (dice) dice.visible = false;
}

function showHandItem(name) {
  if (!armGroup) return;
  hideAllHandItems();
  const item = armGroup.getObjectByName(name);
  if (item) item.visible = true;
}

function isItemAvailable(index) {
  if (index === 0) return true; // javelin always available
  if (index === 1) return beerAvailable && !beerFinished;
  if (index === 2) return diceAvailable && diceThrowsRemaining > 0;
  if (index === 3) return bottle2Available && !bottle2Completed;
  return false;
}

function cycleToNextItem() {
  // Find next available item
  let start = currentItemIndex;
  for (let i = 1; i <= 4; i++) {
    let next = (start + i) % 4;
    if (isItemAvailable(next)) {
      switchToItem(next);
      return;
    }
  }
}

function switchToItem(index) {
  currentItemIndex = index;

  if (index === 0) {
    // Javelin
    if (isDrinkingBeer) {
      isDrinkingBeer = false;
      isDrinking = false;
      hideDrinkingUI();
    }
    showHandItem('stickInHand');
    if (armGroup) armGroup.visible = true;
    gameState = STATES.AIMING;
    document.getElementById('crosshair').style.display = '';
    armAnimState = 'idle';
    armAnimTime = 0;
    const instrEl = document.getElementById('run-instruction');
    instrEl.style.display = 'block';
    instrEl.textContent = isMobile ? 'Aim, then hold RUN' : 'Aim, then hold W to run';
  } else if (index === 1) {
    // Beer
    startBeerDrinking();
  } else if (index === 2) {
    // Dice
    showHandItem('diceInHand');
    if (armGroup) armGroup.visible = true;
    gameState = STATES.AIMING;
    document.getElementById('crosshair').style.display = '';
    armAnimState = 'idle';
    armAnimTime = 0;
    const instrEl = document.getElementById('run-instruction');
    instrEl.style.display = 'block';
    instrEl.textContent = isMobile ? 'Tap THROW to roll dice!' : 'Press Space to roll dice!';
  } else if (index === 3) {
    // Wine
    startRoundDrinking();
  }

  updateItemToggleButton();
}

function updateItemToggleButton() {
  const toggle = document.getElementById('bottle-toggle');
  const icon = document.getElementById('bottle-toggle-icon');
  const label = document.getElementById('bottle-toggle-label');

  // Find what the NEXT available item would be
  let nextItem = -1;
  for (let i = 1; i <= 4; i++) {
    let next = (currentItemIndex + i) % 4;
    if (isItemAvailable(next)) {
      nextItem = next;
      break;
    }
  }

  if (nextItem === -1) {
    toggle.style.display = 'none';
    return;
  }

  toggle.style.display = 'flex';
  toggle.classList.remove('completed');

  const names = ['javelin', 'beer', 'dice', 'wine'];
  const icons = ['\uD83C\uDFF9', '\uD83C\uDF7A', '\uD83C\uDFB2', '\uD83C\uDF77'];
  const labels_desktop = ['JAVELIN (D)', 'BEER (D)', 'DICE (D)', 'WINE (D)'];
  const labels_mobile = ['JAVELIN', 'BEER', 'DICE', 'WINE'];

  icon.textContent = icons[nextItem];
  label.textContent = isMobile ? labels_mobile[nextItem] : labels_desktop[nextItem];
}

// ============================================================
// BEER DRINKING
// ============================================================
function startBeerDrinking() {
  preBottle2AimPitch = aimPitch;
  preBottle2AimYaw = aimYaw;
  isDrinkingBeer = true;
  gameState = STATES.DRINKING;
  isDrinking = false;
  drinkGulpTimer = 0;

  // Show UI
  document.getElementById('drink-meter').style.display = 'block';
  document.getElementById('drink-fill').style.height = (beerDrinkProgress * 100) + '%';
  document.getElementById('drink-label').style.display = 'block';
  document.getElementById('drink-label').textContent = 'BEER';
  document.getElementById('nausea-meter').style.display = 'block';
  document.getElementById('nausea-fill').style.height = (nauseaLevel * 100) + '%';
  document.getElementById('nausea-label').style.display = 'block';
  document.getElementById('drink-instruction').style.display = 'block';
  document.getElementById('drink-instruction').textContent = isMobile ? 'Hold DRINK ‚Äî you can stop anytime!' : 'Hold SPACE to drink ‚Äî you can stop anytime!';
  document.getElementById('crosshair').style.display = 'none';

  // Show beer can, hide others
  showHandItem('beerCanInHand');
  if (armGroup) armGroup.visible = true;

  // Update beer level
  if (armGroup) {
    const beerCan = armGroup.getObjectByName('beerCanInHand');
    if (beerCan) {
      const beerLevel = beerCan.getObjectByName('beerLevel');
      if (beerLevel) {
        const remaining = 1 - beerDrinkProgress;
        beerLevel.scale.y = Math.max(0.01, remaining);
        beerLevel.position.y = 0.05 * remaining;
      }
    }
  }

  updateItemToggleButton();
  armAnimState = 'drinking_idle';
  armAnimTime = 0;
}

function updateBeerDrinking(dt, time) {
  if (!isDrinkingBeer) return;

  if (isDrinking) {
    beerDrinkProgress += BEER_DRINK_RATE * dt;
    nauseaLevel += (BEER_NAUSEA_BUILD + BEER_NAUSEA_ACCEL * nauseaLevel) * dt;

    drinkGulpTimer += dt;
    if (drinkGulpTimer >= 0.25) {
      drinkGulpTimer = 0;
      playSound('gulp');
    }
  } else {
    nauseaLevel = Math.max(0, nauseaLevel - BEER_NAUSEA_DECAY * dt);
    drinkGulpTimer = 0;
  }

  beerDrinkProgress = Math.min(beerDrinkProgress, 1);
  nauseaLevel = Math.min(nauseaLevel, 1);

  // Update beer level mesh
  if (armGroup) {
    const beerCan = armGroup.getObjectByName('beerCanInHand');
    if (beerCan) {
      const beerLevel = beerCan.getObjectByName('beerLevel');
      if (beerLevel) {
        const remaining = 1 - beerDrinkProgress;
        beerLevel.scale.y = Math.max(0.01, remaining);
        beerLevel.position.y = 0.05 * remaining;
      }
    }
  }

  // Update UI
  document.getElementById('drink-fill').style.height = (beerDrinkProgress * 100) + '%';
  document.getElementById('nausea-fill').style.height = (nauseaLevel * 100) + '%';
  updateNauseaEffects(time);

  // Puke check
  if (nauseaLevel >= 1) {
    isDrinkingBeer = false;
    triggerPuke();
    return;
  }

  // Beer finished
  if (beerDrinkProgress >= 1) {
    completeBeerDrinking();
    return;
  }
}

function completeBeerDrinking() {
  isDrinking = false;
  isDrinkingBeer = false;
  beerFinished = true;
  beerBoostActive = true;
  wineWobbleIntensity += 0.036;
  playSound('burp');
  hideDrinkingUI();

  // Switch back to javelin
  currentItemIndex = 0;
  showHandItem('stickInHand');
  aimPitch = preBottle2AimPitch;
  aimYaw = preBottle2AimYaw;
  gameState = STATES.AIMING;
  document.getElementById('crosshair').style.display = '';
  armAnimState = 'idle';
  armAnimTime = 0;
  updateItemToggleButton();
}

// ============================================================
// DICE THROWING
// ============================================================
function throwDice() {
  if (diceFlying || diceLanded) return;
  if (diceThrowsRemaining <= 0) return;

  diceThrowsRemaining--;
  diceFlying = true;
  diceLanded = false;
  mexicoActive = false;

  // Randomize values
  diceValues = [Math.floor(Math.random() * 6) + 1, Math.floor(Math.random() * 6) + 1];

  // Clean up old dice
  diceMeshes.forEach(m => scene.remove(m));
  diceMeshes = [];
  diceVelocities = [];
  diceAngularVels = [];

  // Spawn position from player hand
  const spawnY = PLAYER_POS.y + 0.3;
  const spawnZ = PLAYER_POS.z - 0.5;

  for (let i = 0; i < 2; i++) {
    const die = createDieMesh();
    die.scale.set(1.5, 1.5, 1.5);
    const offsetX = (i === 0 ? -0.15 : 0.15) + (Math.random() - 0.5) * 0.1;
    die.position.set(offsetX, spawnY, spawnZ);
    scene.add(die);
    diceMeshes.push(die);

    // Arc velocity ‚Äî forward (-Z) and upward
    diceVelocities.push(new THREE.Vector3(
      (Math.random() - 0.5) * 2,
      4 + Math.random() * 2,
      -3 - Math.random() * 2
    ));
    diceAngularVels.push(new THREE.Vector3(
      (Math.random() - 0.5) * 10,
      (Math.random() - 0.5) * 10,
      (Math.random() - 0.5) * 10
    ));
  }

  // Hide dice in hand
  hideAllHandItems();
  showHandItem('stickInHand');

  const instrEl = document.getElementById('run-instruction');
  instrEl.style.display = 'block';
  instrEl.textContent = 'Rolling...';
}

function updateDicePhysics(dt) {
  if (!diceFlying) return;

  let allStopped = true;

  for (let i = 0; i < diceMeshes.length; i++) {
    const die = diceMeshes[i];
    const vel = diceVelocities[i];
    const angVel = diceAngularVels[i];

    // Gravity
    vel.y -= 9.81 * dt;

    // Move
    die.position.x += vel.x * dt;
    die.position.y += vel.y * dt;
    die.position.z += vel.z * dt;

    // Rotate
    die.rotation.x += angVel.x * dt;
    die.rotation.y += angVel.y * dt;
    die.rotation.z += angVel.z * dt;

    // Terrain collision
    const groundY = getTerrainHeight(die.position.x, die.position.z) + 0.06;
    if (die.position.y < groundY) {
      die.position.y = groundY;
      vel.y = Math.abs(vel.y) * 0.3; // bounce
      vel.x *= 0.7;
      vel.z *= 0.7;
      angVel.multiplyScalar(0.6);
    }

    // Check if stopped
    const speed = vel.length();
    if (speed > 0.1) allStopped = false;
  }

  if (allStopped) {
    diceFlying = false;
    diceLanded = true;
    // Snap dice to ground
    diceMeshes.forEach(die => {
      const gy = getTerrainHeight(die.position.x, die.position.z) + 0.06;
      die.position.y = gy;
    });
    showDiceResult();
  }
}

function renderDieFace(value) {
  // Grid positions: 1-9 in a 3x3 grid (top-left=1, center=5, bottom-right=9)
  const dotMap = {
    1: [5],
    2: [3, 7],
    3: [3, 5, 7],
    4: [1, 3, 7, 9],
    5: [1, 3, 5, 7, 9],
    6: [1, 3, 4, 6, 7, 9]
  };
  const active = dotMap[value] || [];
  let html = '';
  for (let i = 1; i <= 9; i++) {
    if (active.includes(i)) {
      html += '<span class="dot"></span>';
    } else {
      html += '<span class="dot hidden"></span>';
    }
  }
  return html;
}

function showDiceResult() {
  const isMexico = (diceValues[0] === 1 && diceValues[1] === 2) ||
                   (diceValues[0] === 2 && diceValues[1] === 1);
  mexicoActive = isMexico;

  document.getElementById('die-face-1').innerHTML = renderDieFace(diceValues[0]);
  document.getElementById('die-face-2').innerHTML = renderDieFace(diceValues[1]);
  document.getElementById('dice-throws-remaining').textContent =
    diceThrowsRemaining > 0 ? `${diceThrowsRemaining} throw${diceThrowsRemaining !== 1 ? 's' : ''} remaining` : 'No throws left';

  const mexicoText = document.getElementById('mexico-text');
  mexicoText.style.display = isMexico ? 'block' : 'none';

  const overlay = document.getElementById('dice-result');
  overlay.style.display = 'flex';
  overlay.classList.remove('fade-out');

  diceResultTimer = isMexico ? 4.0 : 3.0;

  if (isMexico) {
    playSound('cheer');
    spawnFireworks();
  }

  const instrEl = document.getElementById('run-instruction');
  instrEl.style.display = 'none';
}

function hideDiceResult() {
  const overlay = document.getElementById('dice-result');
  overlay.classList.add('fade-out');
  setTimeout(() => {
    overlay.style.display = 'none';
    overlay.classList.remove('fade-out');
  }, 500);

  // Clean up dice from scene
  diceMeshes.forEach(m => scene.remove(m));
  diceMeshes = [];
  diceLanded = false;
  mexicoActive = false;

  // Return to javelin or stay on dice if throws remain
  if (diceThrowsRemaining > 0) {
    currentItemIndex = 2;
    showHandItem('diceInHand');
    const instrEl = document.getElementById('run-instruction');
    instrEl.style.display = 'block';
    instrEl.textContent = isMobile ? 'Tap THROW to roll dice!' : 'Press Space to roll dice!';
  } else {
    currentItemIndex = 0;
    showHandItem('stickInHand');
    const instrEl = document.getElementById('run-instruction');
    instrEl.style.display = 'block';
    instrEl.textContent = isMobile ? 'Aim, then hold RUN' : 'Aim, then hold W to run';
  }
  updateItemToggleButton();
}

function updateDiceResult(dt) {
  if (!diceLanded) return;
  diceResultTimer -= dt;
  if (diceResultTimer <= 0) {
    hideDiceResult();
  }
}

// ============================================================
// FIREWORKS (Mexico!)
// ============================================================
function spawnFireworks() {
  if (fireworkParticles) {
    scene.remove(fireworkParticles);
    fireworkParticles = null;
  }

  const count = 200;
  const geo = new THREE.BufferGeometry();
  const positions = new Float32Array(count * 3);
  const colors = new Float32Array(count * 3);
  const velocities = [];

  // Spawn above boulder position
  const spawnPos = new THREE.Vector3(-2.4, getTerrainHeight(0, 0.5) + 4, -3.5);

  const colorOptions = [
    [1, 0.2, 0.2], [1, 1, 0.2], [0.2, 1, 0.2], [1, 1, 1],
    [1, 0.5, 0], [0.2, 0.5, 1], [1, 0.2, 1]
  ];

  for (let i = 0; i < count; i++) {
    positions[i * 3] = spawnPos.x;
    positions[i * 3 + 1] = spawnPos.y;
    positions[i * 3 + 2] = spawnPos.z;

    const c = colorOptions[Math.floor(Math.random() * colorOptions.length)];
    colors[i * 3] = c[0];
    colors[i * 3 + 1] = c[1];
    colors[i * 3 + 2] = c[2];

    // Radial burst
    const theta = Math.random() * Math.PI * 2;
    const phi = Math.random() * Math.PI;
    const speed = 3 + Math.random() * 5;
    velocities.push(new THREE.Vector3(
      Math.sin(phi) * Math.cos(theta) * speed,
      Math.cos(phi) * speed * 0.8 + 2,
      Math.sin(phi) * Math.sin(theta) * speed
    ));
  }

  geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
  geo.setAttribute('color', new THREE.BufferAttribute(colors, 3));

  const mat = new THREE.PointsMaterial({
    size: 0.15,
    vertexColors: true,
    transparent: true,
    opacity: 1.0,
    sizeAttenuation: true
  });

  fireworkParticles = new THREE.Points(geo, mat);
  fireworkParticles.userData.velocities = velocities;
  fireworkParticles.userData.life = 2.5;
  scene.add(fireworkParticles);
  fireworkTimer = 2.5;
}

function updateFireworks(dt) {
  if (!fireworkParticles) return;

  fireworkTimer -= dt;
  if (fireworkTimer <= 0) {
    scene.remove(fireworkParticles);
    fireworkParticles = null;
    return;
  }

  const positions = fireworkParticles.geometry.attributes.position.array;
  const vels = fireworkParticles.userData.velocities;
  const totalLife = fireworkParticles.userData.life;

  for (let i = 0; i < vels.length; i++) {
    // Gravity
    vels[i].y -= 4.0 * dt;

    positions[i * 3] += vels[i].x * dt;
    positions[i * 3 + 1] += vels[i].y * dt;
    positions[i * 3 + 2] += vels[i].z * dt;
  }

  fireworkParticles.geometry.attributes.position.needsUpdate = true;
  fireworkParticles.material.opacity = Math.max(0, fireworkTimer / totalLife);
}

// ============================================================
// GAME FLOW
// ============================================================
function showCharacterSelect() {
  gameState = STATES.CHARACTER_SELECT;
  document.getElementById('title-screen').style.display = 'none';
  document.getElementById('character-select').style.display = 'flex';

  const options = document.querySelectorAll('.color-option');
  options.forEach(opt => {
    opt.addEventListener('click', () => {
      options.forEach(o => o.classList.remove('selected'));
      opt.classList.add('selected');
      playerJacketColor = parseInt(opt.dataset.jacket);
      playerBeanieColor = parseInt(opt.dataset.beanie);
    });
  });

  document.getElementById('ready-btn').addEventListener('click', () => {
    const nameVal = document.getElementById('name-input').value.trim();
    if (nameVal) playerName = nameVal;
    document.getElementById('character-select').style.display = 'none';
    applyPlayerColors();
    startGame();
  });
}

function setUpperArmColor(hex) {
  if (!armGroup) return;
  const upperArm = armGroup.getObjectByName('upperArm');
  if (!upperArm) return;
  upperArm.traverse(child => {
    if (child.isMesh && child.material && child.material.color) {
      child.material.color.setHex(hex);
    }
  });
}

function applyPlayerColors() {
  setUpperArmColor(playerJacketColor);
}

function undressPlayer() {
  isNaked = true;
  setUpperArmColor(0xd4a574); // skin
  updatePlayerBodyColors();
  npcMeshes.forEach(npc => {
    npc.userData.reaction = 'celebrate';
    npc.userData.reactionTimer = 3.0;
  });
}

function restorePlayerClothing() {
  isNaked = false;
  setUpperArmColor(playerJacketColor);
  updatePlayerBodyColors();
}

function startGame() {
  document.getElementById('title-screen').style.display = 'none';
  document.getElementById('character-select').style.display = 'none';
  document.getElementById('hud').style.display = 'block';

  // Create 3rd person body model (uses selected colors)
  if (!playerBodyModel) {
    createPlayerBody();
  } else {
    updatePlayerBodyColors();
  }

  initAudio();
  playSound('ambient');

  gameState = STATES.INTRO_DIALOGUE;

  const intro = getIntroDialogue();
  intro.forEach((d, i) => {
    showDialogue(d.name, d.text, i === intro.length - 1 ? () => {
      // Enter drinking intro instead of going directly to round 1
      gameState = STATES.DRINKING_INTRO;
      const drinkIntro = getDrinkingIntroDialogue();
      drinkIntro.forEach((d2, j) => {
        showDialogue(d2.name, d2.text, j === drinkIntro.length - 1 ? () => {
          startDrinkingMinigame();
        } : null);
      });
    } : null);
  });
}

function resetForThrow() {
  gameState = STATES.AIMING;
  aimPitch = 35;
  aimYaw = 0;
  chargePower = 0;
  isCharging = false;
  chargeDirection = 1;
  armAnimState = 'idle';
  armAnimTime = 0;
  javelinFlying = false;
  javelinLanded = false;
  javelinHitTree = false;
  landedFoul = false;
  landedDrunkFoul = false;

  // Reset run-up state
  playerRunZ = RUN_START_Z;
  runUpSpeed = 0;
  isRunning = false;
  throwReleaseTimer = 0;

  // Reset item cycling and beer/dice state for this throw
  currentItemIndex = 0;
  beerDrinkProgress = 0;
  beerFinished = false;
  isDrinkingBeer = false;
  diceThrowsRemaining = 3;
  diceFlying = false;
  diceLanded = false;
  // Clean up dice meshes
  diceMeshes.forEach(m => scene.remove(m));
  diceMeshes = [];
  document.getElementById('dice-result').style.display = 'none';
  // beerBoostActive persists until used in the throw

  // Show arm and stick in hand (1st person), hide other items
  if (armGroup) {
    armGroup.visible = true;
    hideAllHandItems();
    const stick = armGroup.getObjectByName('stickInHand');
    if (stick) stick.visible = true;
  }

  // Hide 3rd person body model, reset its javelin visibility
  if (playerBodyModel) {
    playerBodyModel.visible = false;
    const armR = playerBodyModel.userData.armR;
    if (armR) {
      const bodyJav = armR.getObjectByName('bodyJavelin');
      if (bodyJav) bodyJav.visible = true;
    }
  }

  // Remove old javelin
  if (javelin) {
    scene.remove(javelin);
    javelin = null;
  }

  // Reset camera orientation and position
  PLAYER_POS.set(0, getTerrainHeight(0, 0) + 1.7, 0);
  camera.rotation.set(0, 0, 0);

  document.getElementById('power-meter').style.display = 'none';
  document.getElementById('speed-meter').style.display = 'none';
  document.getElementById('speed-label').style.display = 'none';
  document.getElementById('distance-display').style.display = 'none';
  document.getElementById('crosshair').style.display = '';

  // Show run-up instructions during aiming
  const instrEl = document.getElementById('run-instruction');
  instrEl.style.display = 'block';
  instrEl.textContent = isMobile ? 'Aim, then hold RUN' : 'Aim, then hold W to run';

  // Update item toggle button
  updateItemToggleButton();

  // Pointer lock will be re-acquired on next click (requires user gesture)
}

function doThrow() {
  if (gameState !== STATES.CHARGING) return;

  // Enter throw release animation (3rd person)
  gameState = STATES.THROW_RELEASE;
  throwReleaseTimer = 0;

  // Hide power meter and speed meter
  document.getElementById('power-meter').style.display = 'none';
  document.getElementById('speed-meter').style.display = 'none';
  document.getElementById('speed-label').style.display = 'none';

  playSound('throw');

  // After 0.3s of throw animation, spawn the javelin
  setTimeout(() => {
    if (gameState !== STATES.THROW_RELEASE) return;

    // Calculate throw direction using locked aim
  const pitchRad = aimPitch * Math.PI / 180;
  const yawRad = aimYaw * Math.PI / 180;

  const dir = new THREE.Vector3(
    Math.sin(yawRad) * Math.cos(pitchRad),
    Math.sin(pitchRad),
    -Math.cos(yawRad) * Math.cos(pitchRad)
  ).normalize();

    // Three factors combine multiplicatively for best throws:
    // a) runUpSpeed¬≤ ‚Äî how fast you were running (0‚Äì1)
    // b) proximity¬≤ ‚Äî how close to foul line you stopped (0‚Äì1)
    // c) chargePower ‚Äî how well you timed the power meter (0‚Äì1)
    //
    // Standing throw (no run): base only, no multiplier bonus
    // Perfect throw (all three maxed): massive bonus

    const distFromStart = RUN_START_Z - playerRunZ;
    const totalRunDist = RUN_START_Z - FOUL_LINE_Z;
    const proximity = Math.max(0, Math.min(1, distFromStart / totalRunDist));

    const speedFactor = runUpSpeed * runUpSpeed;       // 0‚Äì1, exponential
    const proximityFactor = proximity * proximity;      // 0‚Äì1, exponential
    const chargeFactor = chargePower;                   // 0‚Äì1, linear

    // Base speed from charge alone (standing throw caps here)
    const chargeBase = 12 + chargeFactor * 16;          // 12‚Äì28 m/s

    // Combined multiplier: all three factors multiply together
    // Only kicks in when you actually ran (speedFactor > 0)
    const combinedFactor = speedFactor * proximityFactor * chargeFactor;
    const runBonus = combinedFactor * 20;               // 0‚Äì20 m/s bonus

    let totalSpeed = chargeBase + runBonus;              // 12‚Äì48 m/s
    if (beerBoostActive) totalSpeed *= 1.2;              // 20% beer boost
    const vel = dir.multiplyScalar(totalSpeed);

    // Spawn position at player's current run-up position
    const groundY = getTerrainHeight(0, playerRunZ);
    const spawnPos = new THREE.Vector3(0, groundY + 1.5, playerRunZ - 0.5);
  spawnJavelin(spawnPos, vel);

  playSound('flight');
  }, 300);

  // After full 0.5s animation, transition to FLIGHT
  setTimeout(() => {
    if (gameState !== STATES.THROW_RELEASE) return;

    gameState = STATES.FLIGHT;
    beerBoostActive = false; // reset after use

    // Hide 3rd person body, show nothing (javelin follow cam)
    if (playerBodyModel) playerBodyModel.visible = false;
    if (armGroup) armGroup.visible = false;
  }, 500);
}

function retryRound() {
  document.getElementById('result-overlay').style.display = 'none';
  bestDistances[currentRound] = 0;
  randomizeWind();
  resetForThrow();
}

function restartGame() {
  document.getElementById('result-overlay').style.display = 'none';
  document.getElementById('puke-overlay').style.display = 'none';
  document.getElementById('nausea-overlay').style.display = 'none';
  document.getElementById('dice-result').style.display = 'none';
  hideDrinkingUI();

  // Reset drinking state
  drinkProgress = 0;
  nauseaLevel = 0;
  isDrinking = false;
  wineWobbleIntensity = 0;

  // Reset beer/dice state
  beerAvailable = false;
  beerFinished = false;
  beerDrinkProgress = 0;
  beerBoostActive = false;
  isDrinkingBeer = false;
  diceAvailable = false;
  diceThrowsRemaining = 3;
  diceFlying = false;
  diceLanded = false;
  currentItemIndex = 0;
  mexicoActive = false;
  diceMeshes.forEach(m => scene.remove(m));
  diceMeshes = [];
  if (fireworkParticles) { scene.remove(fireworkParticles); fireworkParticles = null; }

  // Reset run-up state
  playerRunZ = RUN_START_Z;
  runUpSpeed = 0;
  isRunning = false;
  throwReleaseTimer = 0;
  PLAYER_POS.set(0, getTerrainHeight(0, 0) + 1.7, 0);

  // Hide body model
  if (playerBodyModel) playerBodyModel.visible = false;

  // Hide run-up UI
  document.getElementById('speed-meter').style.display = 'none';
  document.getElementById('speed-label').style.display = 'none';
  document.getElementById('run-instruction').style.display = 'none';

  // Hide all hand items except javelin
  if (armGroup) {
    hideAllHandItems();
    const stick = armGroup.getObjectByName('stickInHand');
    if (stick) stick.visible = true;
    const bottle = armGroup.getObjectByName('bottleInHand');
    if (bottle) bottle.visible = false;
  }

  // Reset NPC positions to gathered
  npcMeshes.forEach(npc => {
    const gp = npc.userData.gatheredPos;
    if (gp) {
      npc.position.set(gp.x, getTerrainHeight(gp.x, gp.z), gp.z);
      npc.userData.baseY = getTerrainHeight(gp.x, gp.z);
      npc.rotation.y = Math.atan2(-gp.x, 1);
    }
  });
  npcIsWalking = false;
  npcWalkProgress = 0;

  // Reset bottle 2 state
  bottleNumber = 1;
  bottle2Completed = false;
  bottle2Available = false;
  bottle2InProgress = false;

  currentRound = 0;
  currentThrow = 0;
  bestDistances = [0, 0, 0, 0, 0, 0];
  restorePlayerClothing();
  startGame();
}

// ============================================================
// INPUT
// ============================================================
function requestPointerLock() {
  if (isMobile) return;
  renderer.domElement.requestPointerLock();
}

document.addEventListener('pointerlockchange', () => {
  pointerLocked = !!document.pointerLockElement;
});

document.addEventListener('mousemove', (e) => {
  if (!pointerLocked) return;
  if (gameState !== STATES.AIMING) return;

  const sensitivity = 0.15;
  aimYaw = Math.max(-20, Math.min(20, aimYaw - e.movementX * sensitivity));
  aimPitch = Math.max(5, Math.min(55, aimPitch - e.movementY * sensitivity));
});

document.addEventListener('keydown', (e) => {
  // DEV SKIP: Escape to skip to drinking or throwing
  if (e.code === 'Escape') {
    e.preventDefault();
    if (gameState === STATES.DRINKING || gameState === STATES.DRINKING_INTRO ||
        gameState === STATES.DRINKING_COMPLETE || gameState === STATES.CELEBRATION_CAMERA) {
      // Skip from drinking to throwing
      dialogueQueue = [];
      dialogueActive = false;
      document.getElementById('dialogue-box').style.display = 'none';
      hideDrinkingUI();
      drinkProgress = 1;
      isDrinking = false;
      wineWobbleIntensity = 0.05;

      if (armGroup) {
        armGroup.visible = true;
        showHandItem('stickInHand');
      }
      currentItemIndex = 0;
      isDrinkingBeer = false;

      startNPCWalkToPositions();
      currentRound = 0;
      currentThrow = 0;
      randomizeWind();
      resetForThrow();
      console.log('[DEV] Skipped to throwing phase');
    } else if (gameState === STATES.AIMING || gameState === STATES.RUN_UP ||
               gameState === STATES.CHARGING || gameState === STATES.THROW_RELEASE ||
               gameState === STATES.FLIGHT || gameState === STATES.LANDED ||
               gameState === STATES.RESULT || gameState === STATES.ROUND_DIALOGUE) {
      // Already past drinking ‚Äî just reset current throw
      dialogueQueue = [];
      dialogueActive = false;
      document.getElementById('dialogue-box').style.display = 'none';
      document.getElementById('distance-display').style.display = 'none';
      if (javelin) { scene.remove(javelin); javelin = null; }
      javelinFlying = false;
      randomizeWind();
      resetForThrow();
      console.log('[DEV] Reset to throwing phase');
    } else {
      // Skip to drinking from title/intro/character select
      dialogueQueue = [];
      dialogueActive = false;
      document.getElementById('dialogue-box').style.display = 'none';
      document.getElementById('title-screen').style.display = 'none';
      document.getElementById('character-select').style.display = 'none';
      document.getElementById('hud').style.display = 'block';
      if (!playerBodyModel) createPlayerBody();
      initAudio();
      startDrinkingMinigame();
      console.log('[DEV] Skipped to drinking phase');
    }
    return;
  }

  // W key: start run-up from AIMING, or hold to run during RUN_UP
  if (e.code === 'KeyW') {
    if (diceFlying || diceLanded) return; // block during dice
    if (gameState === STATES.AIMING && currentItemIndex !== 0) return; // only run with javelin
    if (gameState === STATES.AIMING) {
      // Lock aim and transition to run-up
      gameState = STATES.RUN_UP;
      isRunning = true;
      playerRunZ = RUN_START_Z;
      runUpSpeed = 0;

      // Exit pointer lock (no more mouse aiming)
      if (document.pointerLockElement) {
        document.exitPointerLock();
      }

      // Hide 1st person arm, show 3rd person body
      if (armGroup) armGroup.visible = false;
      if (playerBodyModel) {
        playerBodyModel.visible = true;
        const groundY = getTerrainHeight(0, playerRunZ);
        playerBodyModel.position.set(0, groundY, playerRunZ);
        playerBodyModel.rotation.y = Math.PI;
      }

      // Show speed meter and instruction
      document.getElementById('crosshair').style.display = 'none';
      document.getElementById('speed-meter').style.display = 'block';
      document.getElementById('speed-label').style.display = 'block';
      document.getElementById('run-instruction').style.display = 'block';
      document.getElementById('run-instruction').textContent = isMobile ? 'Hold RUN + tap THROW near the line!' : 'Hold W + press Space near the foul line!';
      return;
    }
    if (gameState === STATES.RUN_UP) {
      isRunning = true;
    }
    return;
  }

  if (e.code === 'Space') {
    e.preventDefault();

    if (dialogueActive) {
      skipOrAdvanceDialogue();
      return;
    }

    if (gameState === STATES.DRINKING) {
      isDrinking = true;
      armAnimState = 'drinking_active';
      armAnimTime = 0;
      return;
    }

    // Space during RUN_UP: start charging while still running
    if (gameState === STATES.RUN_UP) {
      gameState = STATES.CHARGING;
      isCharging = true;
      // Don't touch isRunning ‚Äî player keeps running if W is held
      chargePower = 0;
      chargeDirection = 1;
      document.getElementById('power-meter').style.display = 'block';
      document.getElementById('run-instruction').style.display = 'none';
      return;
    }

    // Block Space during dice flight/result
    if (diceFlying || diceLanded) return;

    // Space during AIMING with dice selected: throw dice
    if (gameState === STATES.AIMING && currentItemIndex === 2) {
      throwDice();
      return;
    }

    // Space during AIMING (no run-up, standing throw) ‚Äî javelin only
    if (gameState === STATES.AIMING && currentItemIndex === 0) {
      // Skip run-up entirely ‚Äî standing throw
      gameState = STATES.RUN_UP;
      playerRunZ = RUN_START_Z;
      runUpSpeed = 0;
      isRunning = false;

      // Exit pointer lock
      if (document.pointerLockElement) {
        document.exitPointerLock();
      }

      // Hide 1st person arm, show 3rd person body
      if (armGroup) armGroup.visible = false;
      if (playerBodyModel) {
        playerBodyModel.visible = true;
        const groundY = getTerrainHeight(0, playerRunZ);
        playerBodyModel.position.set(0, groundY, playerRunZ);
        playerBodyModel.rotation.y = Math.PI;
      }

      document.getElementById('crosshair').style.display = 'none';

      // Immediately enter charging (standing throw)
      gameState = STATES.CHARGING;
      isCharging = true;
      chargePower = 0;
      chargeDirection = 1;
      document.getElementById('power-meter').style.display = 'block';
    }
  }

  if (e.code === 'KeyD') {
    if (diceFlying || diceLanded) return; // block during dice animation
    if (gameState === STATES.DRINKING && bottleNumber === 2) {
      // Toggle from wine drinking back to aiming (then cycle)
      isDrinking = false;
      hideDrinkingUI();
      aimPitch = preBottle2AimPitch;
      aimYaw = preBottle2AimYaw;
      showHandItem('stickInHand');
      if (armGroup) armGroup.visible = true;
      gameState = STATES.AIMING;
      document.getElementById('crosshair').style.display = '';
      armAnimState = 'idle';
      armAnimTime = 0;
      currentItemIndex = 3; // was on wine
      cycleToNextItem();
    } else if (gameState === STATES.DRINKING && isDrinkingBeer) {
      // Toggle from beer drinking back to aiming (then cycle)
      isDrinking = false;
      isDrinkingBeer = false;
      hideDrinkingUI();
      aimPitch = preBottle2AimPitch;
      aimYaw = preBottle2AimYaw;
      showHandItem('stickInHand');
      if (armGroup) armGroup.visible = true;
      gameState = STATES.AIMING;
      document.getElementById('crosshair').style.display = '';
      armAnimState = 'idle';
      armAnimTime = 0;
      currentItemIndex = 1; // was on beer
      cycleToNextItem();
    } else if (gameState === STATES.AIMING) {
      cycleToNextItem();
    }
  }
});

document.addEventListener('keyup', (e) => {
  if (e.code === 'KeyW') {
    isRunning = false;
    return;
  }

  if (e.code === 'Space') {
    if (gameState === STATES.DRINKING) {
      isDrinking = false;
      armAnimState = 'drinking_idle';
      armAnimTime = 0;
      return;
    }
    if (gameState === STATES.CHARGING) {
      isCharging = false;
      doThrow();
    }
  }
});

document.addEventListener('click', () => {
  if (gameState === STATES.TITLE) {
    showCharacterSelect();
    return;
  }

  if (dialogueActive) {
    skipOrAdvanceDialogue();
    return;
  }

  if (gameState === STATES.PUKE_GAMEOVER) {
    restartGame();
    return;
  }

  if (gameState === STATES.BOTTLE2_GAMEOVER) {
    restartGame();
    return;
  }

  if (gameState === STATES.VICTORY) {
    restartGame();
    return;
  }

  if (gameState === STATES.DEFEAT) {
    retryRound();
    return;
  }

  if (document.getElementById('result-overlay').style.display === 'flex') {
    if (gameState === STATES.DEFEAT) retryRound();
    else restartGame();
    return;
  }

  if (gameState === STATES.AIMING && !pointerLocked) {
    requestPointerLock();
  }
});

document.getElementById('bottle-toggle').addEventListener('click', (e) => {
  e.stopPropagation();
  if (diceFlying || diceLanded) return;
  if (gameState === STATES.DRINKING && bottleNumber === 2) {
    // Toggle from wine drinking ‚Üí cycle
    isDrinking = false;
    hideDrinkingUI();
    showHandItem('stickInHand');
    if (armGroup) armGroup.visible = true;
    aimPitch = preBottle2AimPitch;
    aimYaw = preBottle2AimYaw;
    gameState = STATES.AIMING;
    document.getElementById('crosshair').style.display = '';
    armAnimState = 'idle';
    armAnimTime = 0;
    currentItemIndex = 3;
    cycleToNextItem();
  } else if (gameState === STATES.DRINKING && isDrinkingBeer) {
    // Toggle from beer drinking ‚Üí cycle
    isDrinking = false;
    isDrinkingBeer = false;
    hideDrinkingUI();
    showHandItem('stickInHand');
    if (armGroup) armGroup.visible = true;
    aimPitch = preBottle2AimPitch;
    aimYaw = preBottle2AimYaw;
    gameState = STATES.AIMING;
    document.getElementById('crosshair').style.display = '';
    armAnimState = 'idle';
    armAnimTime = 0;
    currentItemIndex = 1;
    cycleToNextItem();
  } else if (gameState === STATES.AIMING) {
    cycleToNextItem();
  }
});

// ============================================================
// MOBILE TOUCH SUPPORT
// ============================================================
// Prevent default touch behaviors (scrolling/bouncing)
document.addEventListener('touchmove', (e) => {
  const tag = e.target.tagName;
  if (tag === 'INPUT' || tag === 'BUTTON') return;
  e.preventDefault();
}, { passive: false });

document.addEventListener('touchstart', (e) => {
  const tag = e.target.tagName;
  if (tag === 'INPUT' || tag === 'BUTTON') return;
  e.preventDefault();
}, { passive: false });

if (isMobile) {
  // Touch aiming
  let aimTouchId = null;
  let lastAimX = 0, lastAimY = 0;

  const aimZone = document.getElementById('touch-aim-zone');

  aimZone.addEventListener('touchstart', (e) => {
    if (aimTouchId !== null) return;
    const t = e.changedTouches[0];
    aimTouchId = t.identifier;
    lastAimX = t.clientX;
    lastAimY = t.clientY;
  });

  aimZone.addEventListener('touchmove', (e) => {
    for (let i = 0; i < e.changedTouches.length; i++) {
      const t = e.changedTouches[i];
      if (t.identifier !== aimTouchId) continue;
      if (gameState !== STATES.AIMING) break;
      const dx = t.clientX - lastAimX;
      const dy = t.clientY - lastAimY;
      const sensitivity = 0.3;
      aimYaw = Math.max(-20, Math.min(20, aimYaw - dx * sensitivity));
      aimPitch = Math.max(5, Math.min(55, aimPitch - dy * sensitivity));
      lastAimX = t.clientX;
      lastAimY = t.clientY;
    }
  });

  aimZone.addEventListener('touchend', (e) => {
    for (let i = 0; i < e.changedTouches.length; i++) {
      if (e.changedTouches[i].identifier === aimTouchId) {
        aimTouchId = null;
        break;
      }
    }
  });
  aimZone.addEventListener('touchcancel', () => { aimTouchId = null; });

  // Touch drink button
  const drinkBtn = document.getElementById('touch-drink-btn');
  drinkBtn.addEventListener('touchstart', (e) => {
    e.stopPropagation();
    if (gameState !== STATES.DRINKING) return;
    isDrinking = true;
    armAnimState = 'drinking_active';
    armAnimTime = 0;
  });
  drinkBtn.addEventListener('touchend', (e) => {
    e.stopPropagation();
    if (gameState !== STATES.DRINKING) return;
    isDrinking = false;
    armAnimState = 'drinking_idle';
    armAnimTime = 0;
  });
  drinkBtn.addEventListener('touchcancel', () => {
    isDrinking = false;
    armAnimState = 'drinking_idle';
    armAnimTime = 0;
  });

  // Touch throw button (now serves as charge during RUN_UP, release to throw during CHARGING)
  const throwBtn = document.getElementById('touch-throw-btn');
  throwBtn.addEventListener('touchstart', (e) => {
    e.stopPropagation();
    // Dice throw on mobile
    if (gameState === STATES.AIMING && currentItemIndex === 2 && !diceFlying && !diceLanded) {
      throwDice();
      return;
    }
    if (gameState === STATES.RUN_UP) {
      // Start charging while still running
      gameState = STATES.CHARGING;
      isCharging = true;
      chargePower = 0;
      chargeDirection = 1;
      document.getElementById('power-meter').style.display = 'block';
      document.getElementById('run-instruction').style.display = 'none';
    }
  });
  throwBtn.addEventListener('touchend', (e) => {
    e.stopPropagation();
    if (gameState === STATES.CHARGING) {
      isCharging = false;
      doThrow();
    }
  });
  throwBtn.addEventListener('touchcancel', () => {
    if (gameState === STATES.CHARGING) {
      isCharging = false;
      doThrow();
    }
  });

  // Touch run button
  const runBtn = document.getElementById('touch-run-btn');
  runBtn.addEventListener('touchstart', (e) => {
    e.stopPropagation();
    if (gameState === STATES.AIMING && currentItemIndex === 0) {
      // Start run-up (javelin only)
      gameState = STATES.RUN_UP;
      isRunning = true;
      playerRunZ = RUN_START_Z;
      runUpSpeed = 0;

      if (armGroup) armGroup.visible = false;
      if (playerBodyModel) {
        playerBodyModel.visible = true;
        const groundY = getTerrainHeight(0, playerRunZ);
        playerBodyModel.position.set(0, groundY, playerRunZ);
        playerBodyModel.rotation.y = Math.PI;
      }

      document.getElementById('crosshair').style.display = 'none';
      document.getElementById('speed-meter').style.display = 'block';
      document.getElementById('speed-label').style.display = 'block';
      document.getElementById('run-instruction').style.display = 'block';
      document.getElementById('run-instruction').textContent = 'Hold RUN + tap THROW near the line!';
    } else if (gameState === STATES.RUN_UP) {
      isRunning = true;
    }
  });
  runBtn.addEventListener('touchend', (e) => {
    e.stopPropagation();
    isRunning = false;
  });
  runBtn.addEventListener('touchcancel', () => {
    isRunning = false;
  });
}

// Show/hide mobile controls based on game state
function updateMobileControls() {
  if (!isMobile) return;
  const container = document.getElementById('mobile-controls');
  const drinkBtn = document.getElementById('touch-drink-btn');
  const throwBtn = document.getElementById('touch-throw-btn');
  const runBtn = document.getElementById('touch-run-btn');
  const aimZone = document.getElementById('touch-aim-zone');

  if (gameState === STATES.DRINKING) {
    container.style.display = 'block';
    drinkBtn.style.display = 'flex';
    throwBtn.style.display = 'none';
    runBtn.style.display = 'none';
    aimZone.style.display = 'none';
  } else if (gameState === STATES.AIMING && currentItemIndex === 2 && !diceFlying && !diceLanded) {
    // Dice selected: show throw button instead of run
    container.style.display = 'block';
    drinkBtn.style.display = 'none';
    throwBtn.style.display = 'flex';
    throwBtn.innerHTML = 'ROLL<br>DICE';
    runBtn.style.display = 'none';
    aimZone.style.display = 'none';
  } else if (gameState === STATES.AIMING) {
    container.style.display = 'block';
    drinkBtn.style.display = 'none';
    throwBtn.style.display = 'none';
    if (currentItemIndex === 0) {
      runBtn.style.display = 'flex';
    } else {
      runBtn.style.display = 'none';
    }
    aimZone.style.display = currentItemIndex === 0 ? 'block' : 'none';
  } else if (gameState === STATES.RUN_UP) {
    container.style.display = 'block';
    drinkBtn.style.display = 'none';
    throwBtn.style.display = 'flex';
    throwBtn.innerHTML = 'HOLD TO<br>CHARGE';
    runBtn.style.display = 'flex';
    aimZone.style.display = 'none';
  } else if (gameState === STATES.CHARGING) {
    container.style.display = 'block';
    drinkBtn.style.display = 'none';
    throwBtn.style.display = 'flex';
    throwBtn.innerHTML = 'HOLD TO<br>CHARGE';
    runBtn.style.display = 'none';
    aimZone.style.display = 'none';
  } else {
    container.style.display = 'none';
  }
}

window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

// ============================================================
// UPDATE LOOP
// ============================================================
function updateCharging(dt) {
  if (!isCharging) return;

  chargePower += chargeDirection * dt * 1.2;
  if (chargePower >= 1) { chargePower = 1; chargeDirection = -1; }
  if (chargePower <= 0) { chargePower = 0; chargeDirection = 1; }

  document.getElementById('power-fill').style.height = (chargePower * 100) + '%';

  // Audio tick
  if (Math.random() < 0.1) playSound('charge', { power: chargePower });
}

function updateArmAnimation(dt, time) {
  if (!armGroup) return;

  const stick = armGroup.getObjectByName('stickInHand');
  const upperArm = armGroup.getObjectByName('upperArm');
  const forearm = armGroup.getObjectByName('forearm');
  const hand = armGroup.getObjectByName('hand');
  const elbow = armGroup.getObjectByName('elbow');

  armAnimTime += dt;

  // Breathing bob
  const breath = Math.sin(time * 2) * 0.01;

  // Ensure arm is visible in 1st person states (not during 3rd person run-up/throw)
  const isThirdPerson = gameState === STATES.RUN_UP || gameState === STATES.CHARGING ||
                         gameState === STATES.THROW_RELEASE;
  if (armAnimState !== 'follow' && !isThirdPerson) {
    armGroup.visible = true;
  }

  // Only hand visible ‚Äî hide upper arm, elbow, forearm
  if (upperArm) upperArm.visible = false;
  if (elbow) elbow.visible = false;
  if (forearm) forearm.visible = false;

  switch (armAnimState) {
    case 'idle':
      armGroup.position.set(0.35, -0.3 + breath, -0.5);
      armGroup.rotation.set(0, 0, 0);
      if (forearm) forearm.rotation.set(-0.3, 0, 0);
      break;

    case 'windup': {
      const t = Math.min(armAnimTime / 0.4, 1);
      // Arm pulls back
      armGroup.position.set(
        0.35 + t * 0.1,
        -0.3 + breath + t * 0.15,
        -0.5 + t * 0.3
      );
      armGroup.rotation.x = -t * 0.8;
      if (upperArm) upperArm.rotation.z = -0.2 + t * 0.3;
      break;
    }

    case 'release': {
      const t = Math.min(armAnimTime / 0.2, 1);
      // Fast forward whip
      armGroup.position.set(
        0.35 + 0.1 * (1 - t),
        -0.3 + breath + 0.15 * (1 - t),
        -0.5 + 0.3 - t * 0.6
      );
      armGroup.rotation.x = -0.8 + t * 1.2;

      if (t >= 1) {
        armAnimState = 'follow';
        armAnimTime = 0;
      }
      break;
    }

    case 'follow': {
      const t = Math.min(armAnimTime / 0.5, 1);
      armGroup.position.set(
        0.35,
        -0.3 + breath,
        -0.5 - 0.3 * (1 - t)
      );
      armGroup.rotation.x = 0.4 * (1 - t);
      if (t >= 1) {
        armGroup.visible = false;
      }
      break;
    }

    case 'drinking_idle':
      // Holds bottle at chest level, centered
      armGroup.position.set(-0.15, -0.25 + breath, -0.7);
      armGroup.rotation.set(-0.3, 0, 0);
      if (upperArm) upperArm.rotation.set(0, 0, -0.15);
      if (forearm) forearm.rotation.set(-0.4, 0, 0);
      break;

    case 'drinking_active': {
      // Tilts arm up to bring bottle to mouth, centered, shakes at high nausea
      const shake = nauseaLevel > 0.5 ? Math.sin(time * 20) * nauseaLevel * 0.04 : 0;
      armGroup.position.set(0.05, -0.2 + shake, 0.05 + breath, 0.55);
      armGroup.rotation.set(1.2, 0.1, shake * 2);
      if (upperArm) upperArm.rotation.set(0, 0, -0.05);
      if (forearm) forearm.rotation.set(-0.8, 0, 0);
      break;
    }

    case 'drinking_done': {
      // Lowers bottle triumphantly
      const t = Math.min(armAnimTime / 0.6, 1);
      armGroup.position.set(0.35, -0.15 + breath - t * 0.15, -0.45);
      armGroup.rotation.set(-0.3 * (1 - t), 0, 0);
      break;
    }
  }
}

function updateCamera(dt, time) {
  if (gameState === STATES.TITLE || gameState === STATES.CHARACTER_SELECT) {
    // Slow pan around the forest
    const panX = Math.sin(time * 0.1) * 5;
    const panZ = Math.cos(time * 0.1) * 5 - 10;
    camera.position.set(
      panX,
      getTerrainHeight(panX, panZ) + 2.5 + Math.sin(time * 0.15) * 0.3,
      panZ
    );
    camera.lookAt(0, getTerrainHeight(0, -30) + 2, -30);
    return;
  }

  if (gameState === STATES.CELEBRATION_CAMERA) {
    celebrationAnimTime += dt;

    const playerGround = new THREE.Vector3(PLAYER_POS.x, getTerrainHeight(0, 0), PLAYER_POS.z);

    if (celebrationAnimTime < 1.4) {
      // ASCENT: rise from first-person to bird's eye
      const t = easeInOutCubic(celebrationAnimTime / 1.4);
      camera.position.set(
        PLAYER_POS.x + 2 * t,
        PLAYER_POS.y + 30 * t,
        PLAYER_POS.z + 3 * t
      );
      camera.lookAt(playerGround);

    } else if (celebrationAnimTime < 4.1) {
      // ORBIT: gentle arc at altitude showing forest/field/dome
      const t = (celebrationAnimTime - 1.4) / 2.7;
      const angle = t * Math.PI * 0.8;
      camera.position.set(
        PLAYER_POS.x + Math.sin(angle) * 10,
        PLAYER_POS.y + 30 + Math.sin(t * Math.PI) * 3,
        PLAYER_POS.z + Math.cos(angle) * 10 - 5
      );
      camera.lookAt(playerGround.x, playerGround.y, playerGround.z - 10);

    } else if (celebrationAnimTime < CELEBRATION_DURATION) {
      // DESCENT: return to first person
      const t = easeInOutCubic((celebrationAnimTime - 4.1) / 1.4);
      camera.position.set(
        PLAYER_POS.x + 2 * (1 - t),
        PLAYER_POS.y + 30 * (1 - t),
        PLAYER_POS.z + 3 * (1 - t)
      );
      // Transition lookAt from ground to forward view
      const lookY = playerGround.y * (1 - t) + PLAYER_POS.y * t;
      const lookZ = playerGround.z * (1 - t) + (PLAYER_POS.z - 5) * t;
      camera.lookAt(PLAYER_POS.x, lookY, lookZ);

    } else {
      // Animation complete
      onCelebrationComplete();
    }
    return;
  }

  // Drinking states: first-person at PLAYER_POS, looking forward
  if (gameState === STATES.DRINKING || gameState === STATES.DRINKING_INTRO ||
      gameState === STATES.DRINKING_COMPLETE || gameState === STATES.PUKE_GAMEOVER ||
      gameState === STATES.BOTTLE2_GAMEOVER) {
    camera.position.copy(PLAYER_POS);
    // Nausea wobble is applied in updateNauseaEffects() during DRINKING
    if (gameState !== STATES.DRINKING) {
      camera.rotation.set(0, 0, 0);
    }
    return;
  }

  if (gameState === STATES.AIMING) {
    camera.position.copy(PLAYER_POS);

    // Apply aim rotation
    const pitchRad = -aimPitch * Math.PI / 180 + Math.PI / 6;
    const yawRad = aimYaw * Math.PI / 180;
    camera.rotation.set(pitchRad, yawRad, 0, 'YXZ');

    // Persistent wine wobble after drinking
    if (wineWobbleIntensity > 0) {
      camera.rotation.z += Math.sin(time * 1.8) * wineWobbleIntensity;
      camera.rotation.x += Math.sin(time * 1.3) * wineWobbleIntensity * 0.5;
    }
    return;
  }

  // 3rd person camera for run-up, charging, and throw release
  if (gameState === STATES.RUN_UP || gameState === STATES.CHARGING || gameState === STATES.THROW_RELEASE) {
    const playerGroundY = getTerrainHeight(0, playerRunZ);
    const targetPos = new THREE.Vector3(1.5, playerGroundY + 2.5, playerRunZ + 4);
    const lookTarget = new THREE.Vector3(0, playerGroundY + 1.5, playerRunZ - 3);

    camera.position.lerp(targetPos, 0.08);
    camera.lookAt(lookTarget);
    return;
  }

  if (gameState === STATES.FLIGHT && javelin) {
    // Follow javelin
    const followPos = javelin.position.clone().add(new THREE.Vector3(2, 3, 5));
    camera.position.lerp(followPos, 0.05);
    camera.lookAt(javelin.position);
    return;
  }

  if (gameState === STATES.LANDED || gameState === STATES.RESULT) {
    if (javelin) {
      camera.lookAt(javelin.position);
    }
  }
}

function updateParticles(dt, time) {
  // Falling leaves
  if (leafParticles) {
    const pos = leafParticles.geometry.attributes.position;
    const vels = leafParticles.userData.velocities;
    for (let i = 0; i < pos.count; i++) {
      let x = pos.getX(i);
      let y = pos.getY(i);
      let z = pos.getZ(i);

      // Flutter
      const v = vels[i];
      x += (v.x + Math.sin(time * v.speed + v.phase) * 0.3 + Math.cos(windAngle) * windSpeed * 0.05) * dt;
      y += v.y * dt;
      z += (v.z + Math.cos(time * v.speed + v.phase) * 0.2 + Math.sin(windAngle) * windSpeed * 0.05) * dt;

      // Reset when below terrain
      if (y < getTerrainHeight(x, z)) {
        x = (Math.random() - 0.5) * 80;
        y = 12 + Math.random() * 8;
        z = (Math.random() - 0.5) * 80 - 20;
      }

      pos.setXYZ(i, x, y, z);
    }
    pos.needsUpdate = true;
  }

  // Wind particles
  if (windParticles) {
    const pos = windParticles.geometry.attributes.position;
    for (let i = 0; i < pos.count; i++) {
      let x = pos.getX(i);
      let y = pos.getY(i);
      let z = pos.getZ(i);

      x += Math.cos(windAngle) * windSpeed * 0.5 * dt;
      z += Math.sin(windAngle) * windSpeed * 0.5 * dt;
      y += Math.sin(time * 3 + i) * 0.02 * dt;

      if (Math.abs(x) > 40 || Math.abs(z + 20) > 40) {
        x = (Math.random() - 0.5) * 60;
        z = (Math.random() - 0.5) * 60 - 20;
        y = getTerrainHeight(x, z) + 0.2 + Math.random() * 1.5;
      }

      pos.setXYZ(i, x, y, z);
    }
    pos.needsUpdate = true;
  }

  // Birds
  if (birdParticles) {
    const pos = birdParticles.geometry.attributes.position;
    const centers = birdParticles.userData.centers;
    const phases = birdParticles.userData.phases;
    for (let i = 0; i < pos.count; i++) {
      const c = centers[i];
      const p = phases[i];
      const r = 3;
      pos.setXYZ(i,
        c.x + Math.sin(time * 0.5 + p) * r,
        c.y + Math.sin(time * 0.3 + p * 2) * 0.5,
        c.z + Math.cos(time * 0.5 + p) * r
      );
    }
    pos.needsUpdate = true;
  }
}

function startNPCWalkToPositions() {
  npcIsWalking = true;
  npcWalkProgress = 0;
}

function updateNPCWalk(dt, time) {
  if (!npcIsWalking) return;
  npcWalkProgress += dt / NPC_WALK_DURATION;
  const t = Math.min(npcWalkProgress, 1);
  const et = easeInOutCubic(t);

  npcMeshes.forEach(npc => {
    const gp = npc.userData.gatheredPos;
    const fp = npc.userData.finalPos;
    if (!gp || !fp) return;

    const cx = gp.x + (fp.x - gp.x) * et;
    const cz = gp.z + (fp.z - gp.z) * et;
    const cy = getTerrainHeight(cx, cz);
    npc.position.set(cx, cy, cz);
    npc.userData.baseY = cy;

    // Face walking direction
    const dx = fp.x - gp.x;
    const dz = fp.z - gp.z;
    const walkRot = Math.atan2(dx, dz);
    const finalRot = npc.userData.finalRotY;
    if (t < 0.85) {
      npc.rotation.y = walkRot;
    } else {
      const blend = (t - 0.85) / 0.15;
      npc.rotation.y = walkRot + (finalRot - walkRot) * blend;
    }

    // Animate legs
    const legL = npc.userData.legL;
    const legR = npc.userData.legR;
    if (legL) legL.rotation.x = Math.sin(time * 6) * 0.4;
    if (legR) legR.rotation.x = -Math.sin(time * 6) * 0.4;
  });

  if (t >= 1) {
    npcIsWalking = false;
    // Reset leg rotations
    npcMeshes.forEach(npc => {
      if (npc.userData.legL) npc.userData.legL.rotation.x = 0;
      if (npc.userData.legR) npc.userData.legR.rotation.x = 0;
    });
  }
}

function updateNPCs(dt, time) {
  updateNPCWalk(dt, time);
  npcMeshes.forEach(npc => {
    // Weight shift idle
    const phase = npc.userData.animPhase;
    const baseY = npc.userData.baseY || 0;
    npc.position.y = baseY + Math.sin(time * 1.2 + phase) * 0.02;

    const armL = npc.userData.armL;
    const armR = npc.userData.armR;

    if (npc.userData.reactionTimer > 0) {
      npc.userData.reactionTimer -= dt;
      const reaction = npc.userData.reaction;

      if (reaction === 'celebrate') {
        if (armL) armL.rotation.z = 0.15 + Math.sin(time * 8) * 1.2;
        if (armR) armR.rotation.z = -0.15 - Math.sin(time * 8 + 0.5) * 1.2;
      } else if (reaction === 'clap') {
        if (armL) armL.rotation.z = 0.15 + Math.sin(time * 6) * 0.5;
        if (armR) armR.rotation.z = -0.15 - Math.sin(time * 6 + Math.PI) * 0.5;
      } else if (reaction === 'headshake') {
        npc.rotation.y += Math.sin(time * 6) * 0.02;
      }
    } else {
      // Idle arm sway
      if (armL) armL.rotation.z = 0.15 + Math.sin(time * 0.8 + phase) * 0.05;
      if (armR) armR.rotation.z = -0.15 - Math.sin(time * 0.8 + phase + 1) * 0.05;
    }
  });
}

function updateShaders(time) {
  if (treesInstanced && treesInstanced.material.uniforms) {
    treesInstanced.material.uniforms.time.value = time;
    treesInstanced.material.uniforms.windStr.value = windSpeed / 5;
  }
  if (treesInstanced && treesInstanced.userData.crownMesh) {
    const crown = treesInstanced.userData.crownMesh;
    if (crown.material.uniforms) {
      crown.material.uniforms.time.value = time;
      crown.material.uniforms.windStr.value = windSpeed / 5;
    }
  }
  // Birch tree shaders
  if (birchInstanced && birchInstanced.material.uniforms) {
    birchInstanced.material.uniforms.time.value = time;
    birchInstanced.material.uniforms.windStr.value = windSpeed / 5;
  }
  if (birchInstanced && birchInstanced.userData.crownMesh) {
    const birchCrown = birchInstanced.userData.crownMesh;
    if (birchCrown.material.uniforms) {
      birchCrown.material.uniforms.time.value = time;
      birchCrown.material.uniforms.windStr.value = windSpeed / 5;
    }
  }
}

function updateHUD() {
  if (gameState === STATES.AIMING || gameState === STATES.CHARGING || gameState === STATES.RUN_UP) {
    const round = ROUNDS[currentRound];
    let infoHtml =
      `Round ${currentRound + 1}: "${round.name}"<br>` +
      `Target: ~${round.target}m<br>` +
      `Best: ${bestDistances[currentRound] > 0 ? '~' + Math.round(bestDistances[currentRound]) + 'm' : '-'}`;

    // Show bottle 2 progress during aiming
    if (bottle2InProgress && !bottle2Completed) {
      infoHtml += `<br>Bottle 2: ${Math.round(drinkProgress * 100)}%`;
    }

    // Show beer/dice info in HUD
    if (beerAvailable && !beerFinished) {
      infoHtml += `<br>Beer: ${Math.round(beerDrinkProgress * 100)}%`;
    } else if (beerFinished) {
      infoHtml += `<br>Beer: DONE (+20%)`;
    }
    if (diceAvailable) {
      infoHtml += `<br>Dice: ${diceThrowsRemaining} left`;
    }

    document.getElementById('info-panel').innerHTML = infoHtml;
    document.getElementById('wind-indicator').innerHTML = getWindDisplay();

    if (gameState === STATES.AIMING) {
    document.getElementById('angle-display').textContent = `Angle: ${Math.round(aimPitch)}¬∞`;
    } else {
      document.getElementById('angle-display').textContent = '';
    }

    // Item toggle button
    const hasAnyItem = beerAvailable || diceAvailable || bottle2Available;
    if (hasAnyItem && gameState === STATES.AIMING) {
      updateItemToggleButton();
    } else if (!hasAnyItem || (gameState !== STATES.AIMING && gameState !== STATES.DRINKING)) {
      document.getElementById('bottle-toggle').style.display = 'none';
    }
  } else {
    document.getElementById('angle-display').textContent = '';
    // Keep toggle visible during DRINKING for bottle 2 or beer
    if (gameState === STATES.DRINKING && (bottleNumber === 2 || isDrinkingBeer)) {
      updateItemToggleButton();
    } else if (gameState !== STATES.DRINKING) {
      document.getElementById('bottle-toggle').style.display = 'none';
    }
  }
}

// ============================================================
// MAIN LOOP
// ============================================================
function animate() {
  requestAnimationFrame(animate);

  const dt = Math.min(clock.getDelta(), 0.05);
  const time = clock.getElapsedTime();

  // State updates
  if (gameState === STATES.DRINKING) updateDrinking(dt, time);
  if (gameState === STATES.RUN_UP || gameState === STATES.CHARGING) updateRunUp(dt);
  if (gameState === STATES.CHARGING) updateCharging(dt);
  if (gameState === STATES.THROW_RELEASE) {
    throwReleaseTimer += dt;
  }
  if (gameState === STATES.FLIGHT) updateJavelinPhysics(dt);

  // Dice physics and result timer
  if (diceFlying) updateDicePhysics(dt);
  if (diceLanded) updateDiceResult(dt);
  updateFireworks(dt);

  // Nausea decays during non-drinking states when bottle 2 is in progress
  if (bottle2InProgress && gameState !== STATES.DRINKING) {
    nauseaLevel = Math.max(0, nauseaLevel - BOTTLE2_NAUSEA_DECAY_RATE * dt);
  }

  updateCamera(dt, time);
  updateArmAnimation(dt, time);
  updatePlayerBodyAnimation(dt, time);
  updateParticles(dt, time);
  updateNPCs(dt, time);
  updateShaders(time);
  updateDialogue(dt);
  updateHUD();
  updateMobileControls();

  renderer.render(scene, camera);
}

// ============================================================
// INIT
// ============================================================
initScene();
animate();

// Mobile text overrides
if (isMobile) {
  document.getElementById('start-text').textContent = 'Tap to begin';
  document.getElementById('dialogue-continue').textContent = 'Tap to continue';
  document.querySelector('#puke-overlay p').textContent = 'Tap to try again...';
}

</script>
</body>
</html>
